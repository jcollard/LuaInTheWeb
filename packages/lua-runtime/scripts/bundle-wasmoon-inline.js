#!/usr/bin/env node
/**
 * Bundle wasmoon (Lua runtime) into a self-contained JavaScript string.
 *
 * This script:
 * 1. Reads wasmoon's index.js
 * 2. Reads and base64-encodes glue.wasm
 * 3. Creates a wrapper that provides the WASM binary inline
 * 4. Outputs a TypeScript file with WASMOON_INLINE_JS export
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Paths
const WASMOON_DIR = join(__dirname, '..', '..', '..', 'node_modules', 'wasmoon', 'dist');
const WASMOON_JS = join(WASMOON_DIR, 'index.js');
const WASMOON_WASM = join(WASMOON_DIR, 'glue.wasm');
const OUTPUT_DIR = join(__dirname, '..', 'src');
const OUTPUT_TS = join(OUTPUT_DIR, 'wasmoon-inline.generated.ts');

function bundleWasmoon() {
  console.log('Bundling wasmoon for inline exports...');

  // Read wasmoon JavaScript
  if (!existsSync(WASMOON_JS)) {
    throw new Error(`wasmoon not found at ${WASMOON_JS}. Run npm install first.`);
  }
  const wasmoonJs = readFileSync(WASMOON_JS, 'utf-8');
  console.log(`  Read index.js: ${wasmoonJs.length} bytes`);

  // Read and base64 encode the WASM binary
  if (!existsSync(WASMOON_WASM)) {
    throw new Error(`glue.wasm not found at ${WASMOON_WASM}`);
  }
  const wasmBinary = readFileSync(WASMOON_WASM);
  const wasmBase64 = wasmBinary.toString('base64');
  console.log(`  Read glue.wasm: ${wasmBinary.length} bytes -> ${wasmBase64.length} base64 chars`);

  // Create the inline bundle
  // The wrapper:
  // 1. Executes wasmoon UMD (sets up globalThis.wasmoon)
  // 2. Creates a data URL for the embedded WASM binary
  // 3. Creates patched LuaFactory that uses the data URL
  // 4. Exposes patched LuaFactory globally
  //
  // Note: wasmoon's LuaFactory constructor is: constructor(customWasmUri, environmentVariables)
  // It supports data URLs natively: data:application/octet-stream;base64,...
  const bundledCode = `
// Execute wasmoon UMD - this sets up globalThis.wasmoon
${wasmoonJs}

// Embedded WASM binary as data URL (wasmoon natively supports this format)
const WASMOON_WASM_DATA_URL = "data:application/octet-stream;base64,${wasmBase64}";

// Get the original LuaFactory from wasmoon
const OriginalLuaFactory = globalThis.wasmoon.LuaFactory;

// Create a patched LuaFactory that uses embedded WASM via data URL
class LuaFactory {
  constructor(customWasmUri, environmentVariables) {
    // If no custom URI provided, use our embedded WASM data URL
    const wasmUri = customWasmUri || WASMOON_WASM_DATA_URL;
    return new OriginalLuaFactory(wasmUri, environmentVariables);
  }
}

// Copy static properties if any
if (OriginalLuaFactory) {
  Object.keys(OriginalLuaFactory).forEach(key => {
    LuaFactory[key] = OriginalLuaFactory[key];
  });
}

// Expose patched LuaFactory globally
globalThis.LuaFactory = LuaFactory;
`;

  // Escape for template literal
  const escapedCode = bundledCode
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${');

  // Generate TypeScript export
  const tsContent = `/* eslint-disable max-lines */
/**
 * Auto-generated wasmoon bundle with embedded WASM binary.
 * DO NOT EDIT THIS FILE DIRECTLY.
 *
 * This allows HTML exports to work fully offline without CDN dependencies.
 * Run "npm run build:wasmoon" to regenerate this file.
 */
export const WASMOON_INLINE_JS = \`${escapedCode}\`
`;

  // Ensure output directory exists
  if (!existsSync(OUTPUT_DIR)) {
    mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  writeFileSync(OUTPUT_TS, tsContent);

  const totalSize = wasmoonJs.length + wasmBase64.length;
  console.log(`Generated: wasmoon-inline.generated.ts (${totalSize} bytes total)`);
  console.log(`  - JS code: ${wasmoonJs.length} bytes`);
  console.log(`  - WASM (base64): ${wasmBase64.length} bytes`);
}

bundleWasmoon();
