#!/usr/bin/env node
/**
 * Bundle the canvas-standalone.ts into a self-contained JavaScript string.
 *
 * This script uses esbuild to:
 * 1. Bundle canvas-standalone.ts with all dependencies (Lua code)
 * 2. Output an IIFE that exposes setupCanvasBridge, etc. globally
 * 3. Convert the bundled JS to a TypeScript string export
 *
 * Note: Audio is handled separately by AUDIO_INLINE_JS to properly handle
 * browser autoplay policy via user interaction handlers.
 *
 * Following the pattern established by lua-runtime's bundle-audio-inline.js
 */

import { build } from 'esbuild';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const ENTRY_FILE = join(__dirname, '..', 'src', 'runtime', 'canvas-inline-entry.ts');
const OUTPUT_DIR = join(__dirname, '..', 'src', 'runtime');
const OUTPUT_TS = join(OUTPUT_DIR, 'canvas-inline.generated.ts');

// Path to lua-runtime source for direct imports (bypasses package exports)
const LUA_RUNTIME_SRC = join(__dirname, '..', '..', 'lua-runtime', 'src');

async function bundleCanvasInline() {
  console.log('Bundling canvas-inline-entry.ts...');

  // Bundle with esbuild
  const result = await build({
    entryPoints: [ENTRY_FILE],
    bundle: true,
    format: 'iife',
    globalName: 'CanvasInline',
    minify: false, // Keep readable for debugging
    sourcemap: false,
    write: false, // Don't write to disk, capture output
    target: 'es2020',
    platform: 'browser',
    plugins: [
      {
        // Plugin to handle wasmoon - we only use types from it, not runtime code
        // The actual LuaEngine is provided by WASMOON_INLINE_JS at runtime
        name: 'wasmoon-types-only',
        setup(build) {
          // Intercept imports of wasmoon and return empty module
          // since we only use `import type` which is erased at compile time
          build.onResolve({ filter: /^wasmoon$/ }, () => ({
            path: 'wasmoon',
            namespace: 'wasmoon-stub',
          }));
          build.onLoad({ filter: /.*/, namespace: 'wasmoon-stub' }, () => ({
            contents: 'export default {}; export const LuaEngine = {};',
            loader: 'js',
          }));
        },
      },
      {
        // Plugin to resolve lua-runtime imports to specific source files
        // This avoids pulling in LuaEngineFactory which imports wasmoon
        name: 'lua-runtime-resolver',
        setup(build) {
          // Intercept the main lua-runtime import and redirect to a shim
          // that only exports what canvas-standalone actually needs
          build.onResolve({ filter: /^@lua-learning\/lua-runtime$/ }, () => ({
            path: '@lua-learning/lua-runtime',
            namespace: 'lua-runtime-shim',
          }));
          build.onLoad({ filter: /.*/, namespace: 'lua-runtime-shim' }, () => ({
            // Re-export only what canvas-standalone needs, directly from source files
            // Note: WebAudioEngine is handled by AUDIO_INLINE_JS separately
            contents: `
              export { canvasLuaCoreCode } from '${join(LUA_RUNTIME_SRC, 'canvasLuaCode/core.ts').replace(/\\/g, '/')}';
              export { canvasLuaPathCode } from '${join(LUA_RUNTIME_SRC, 'canvasLuaCode/path.ts').replace(/\\/g, '/')}';
              export { canvasLuaStylingCode } from '${join(LUA_RUNTIME_SRC, 'canvasLuaCode/styling.ts').replace(/\\/g, '/')}';
              export { canvasLuaTextCode } from '${join(LUA_RUNTIME_SRC, 'canvasLuaCode/text.ts').replace(/\\/g, '/')}';
              export { canvasLuaInputCode } from '${join(LUA_RUNTIME_SRC, 'canvasLuaCode/input.ts').replace(/\\/g, '/')}';
              export { canvasLuaAudioCode } from '${join(LUA_RUNTIME_SRC, 'canvasLuaCode/audio.ts').replace(/\\/g, '/')}';
            `,
            loader: 'ts',
            resolveDir: LUA_RUNTIME_SRC,
          }));
        },
      },
    ],
  });

  if (result.outputFiles.length === 0) {
    throw new Error('esbuild produced no output');
  }

  const bundledCode = result.outputFiles[0].text;

  // Escape backticks and ${} for template literal
  const escapedCode = bundledCode
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${');

  // Generate TypeScript export
  const tsContent = `/* eslint-disable max-lines */
/**
 * Auto-generated from canvas-inline-entry.ts
 * DO NOT EDIT THIS FILE DIRECTLY - edit the .ts source instead.
 *
 * Bundled canvas bridge for standalone HTML exports.
 * Run "npm run build:canvas" to regenerate this file.
 */
export const CANVAS_INLINE_JS = \`${escapedCode}\`
`;

  // Ensure output directory exists
  if (!existsSync(OUTPUT_DIR)) {
    mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  writeFileSync(OUTPUT_TS, tsContent);
  console.log(`Generated: canvas-inline.generated.ts (${bundledCode.length} bytes)`);
}

bundleCanvasInline().catch((err) => {
  console.error('Failed to bundle canvas inline:', err);
  process.exit(1);
});
