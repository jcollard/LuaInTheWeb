/* eslint-disable max-lines */
/**
 * Auto-generated from canvas-inline-entry.ts
 * DO NOT EDIT THIS FILE DIRECTLY - edit the .ts source instead.
 *
 * Bundled canvas bridge for standalone HTML exports.
 * Run "npm run build:canvas" to regenerate this file.
 */
export const CANVAS_INLINE_JS = `"use strict";
var CanvasInline = (() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // ../lua-runtime/src/canvasLuaCode/core.ts
  var canvasLuaCoreCode = \`
    local _canvas = {}

    -- Canvas lifecycle
    function _canvas.start()
      if __canvas_is_active() then
        error("Canvas is already running. Call canvas.stop() first.")
      end
      __canvas_start():await()
    end

    function _canvas.stop()
      __canvas_stop()
    end

    -- Store the user's callback and wrap with error handling
    local __user_tick_callback = nil
    local __user_tick_location = nil  -- Stores callback definition location
    local __current_font_size = 16  -- Track current font size for draw_label

    function _canvas.tick(callback)
      __user_tick_callback = callback
      -- Capture callback's definition location for better error messages
      local info = debug.getinfo(callback, "S")
      if info then
        local source = info.source or "?"
        local line = info.linedefined or 0
        -- Clean up source name (remove @ prefix if present)
        if source:sub(1, 1) == "@" then
          source = source:sub(2)
        end
        __user_tick_location = source .. ":" .. line
      end
      -- Create a wrapper that uses xpcall to capture stack trace on error
      __canvas_setOnDrawCallback(function()
        if __user_tick_callback then
          local success, err = xpcall(__user_tick_callback, function(e)
            -- Capture stack trace, skip internal frames
            return debug.traceback(e, 2)
          end)
          if not success then
            -- If error doesn't have Lua line info, add callback location
            local errStr = tostring(err)
            if __user_tick_location and not errStr:match(":%d+:") then
              err = __user_tick_location .. ": " .. errStr
            end
            error(err, 0)  -- Re-throw with location included
          end
        end
      end)
    end

    -- Canvas configuration
    function _canvas.set_size(width, height)
      __canvas_setSize(width, height)
    end

    function _canvas.get_width()
      return __canvas_getWidth()
    end

    function _canvas.get_height()
      return __canvas_getHeight()
    end

    -- Drawing state
    function _canvas.clear()
      __canvas_clear()
    end

    function _canvas.clear_rect(x, y, width, height)
      __canvas_clearRect(x, y, width, height)
    end

    -- Helper function to parse hex color string to RGBA
    local function parse_hex_color(hex)
      -- Remove the # prefix
      local color = hex:sub(2)
      local len = #color

      local r, g, b, a

      if len == 3 then
        -- Short form #RGB -> expand to #RRGGBB
        local r1 = tonumber(color:sub(1, 1), 16)
        local g1 = tonumber(color:sub(2, 2), 16)
        local b1 = tonumber(color:sub(3, 3), 16)
        if not r1 or not g1 or not b1 then
          error("Invalid hex color: " .. hex .. ". Contains non-hexadecimal characters")
        end
        r = r1 * 17
        g = g1 * 17
        b = b1 * 17
        a = 255
      elseif len == 6 then
        -- Full form #RRGGBB
        r = tonumber(color:sub(1, 2), 16)
        g = tonumber(color:sub(3, 4), 16)
        b = tonumber(color:sub(5, 6), 16)
        a = 255
        if not r or not g or not b then
          error("Invalid hex color: " .. hex .. ". Contains non-hexadecimal characters")
        end
      elseif len == 8 then
        -- Full form with alpha #RRGGBBAA
        r = tonumber(color:sub(1, 2), 16)
        g = tonumber(color:sub(3, 4), 16)
        b = tonumber(color:sub(5, 6), 16)
        a = tonumber(color:sub(7, 8), 16)
        if not r or not g or not b or not a then
          error("Invalid hex color: " .. hex .. ". Contains non-hexadecimal characters")
        end
      else
        error("Invalid hex color format: " .. hex .. ". Expected #RGB, #RRGGBB, or #RRGGBBAA")
      end

      return r, g, b, a
    end

    function _canvas.set_color(r, g, b, a)
      -- Check if first argument is a hex color string
      if type(r) == 'string' and r:sub(1, 1) == '#' then
        local hr, hg, hb, ha = parse_hex_color(r)
        __canvas_setColor(hr, hg, hb, ha)
      else
        __canvas_setColor(r, g, b, a)
      end
    end

    function _canvas.set_line_width(width)
      __canvas_setLineWidth(width)
    end

    -- Font styling
    function _canvas.set_font_size(size)
      __current_font_size = size
      __canvas_setFontSize(size)
    end

    function _canvas.set_font_family(family)
      __canvas_setFontFamily(family)
    end

    function _canvas.get_text_width(text)
      return __canvas_getTextWidth(text)
    end

    -- Shape drawing
    function _canvas.draw_rect(x, y, w, h)
      __canvas_rect(x, y, w, h)
    end

    function _canvas.fill_rect(x, y, w, h)
      __canvas_fillRect(x, y, w, h)
    end

    function _canvas.draw_circle(x, y, r)
      __canvas_circle(x, y, r)
    end

    function _canvas.fill_circle(x, y, r)
      __canvas_fillCircle(x, y, r)
    end

    function _canvas.draw_line(x1, y1, x2, y2)
      __canvas_line(x1, y1, x2, y2)
    end

    function _canvas.draw_text(x, y, text, options)
      local fontSize = nil
      local fontFamily = nil
      local maxWidth = nil
      if options then
        fontSize = options.font_size
        fontFamily = options.font_family
        maxWidth = options.max_width
      end
      __canvas_text(x, y, text, fontSize, fontFamily, maxWidth)
    end

    function _canvas.stroke_text(x, y, text, options)
      local fontSize = nil
      local fontFamily = nil
      local maxWidth = nil
      if options then
        fontSize = options.font_size
        fontFamily = options.font_family
        maxWidth = options.max_width
      end
      __canvas_strokeText(x, y, text, fontSize, fontFamily, maxWidth)
    end

    -- Image drawing
    -- Supports two forms:
    -- 1. draw_image(name, x, y, width?, height?) - draws at destination with optional scaling
    -- 2. draw_image(name, sx, sy, sw, sh, dx, dy, dw, dh) - crops source and draws to destination
    function _canvas.draw_image(name, x, y, width, height, sx, sy, sw, sh)
      __canvas_drawImage(name, x, y, width, height, sx, sy, sw, sh)
    end

    -- Asset management
    _canvas.assets = {}

    -- Register a directory path to scan for assets
    -- Must be called BEFORE canvas.start()
    function _canvas.assets.add_path(path)
      __canvas_assets_addPath(path)
    end

    -- Create a named reference to a discovered image file
    -- Returns an asset handle that can be used with draw_image
    -- Can be called before or after canvas.start()
    function _canvas.assets.load_image(name, filename)
      return __canvas_assets_loadImage(name, filename)
    end

    -- Create a named reference to a discovered font file
    -- Returns an asset handle that can be used with set_font_family
    -- Can be called before or after canvas.start()
    function _canvas.assets.load_font(name, filename)
      return __canvas_assets_loadFont(name, filename)
    end

    -- Create a named reference to a discovered sound file
    -- Returns an asset handle that can be used with play_sound
    -- Must be called before canvas.start()
    function _canvas.assets.load_sound(name, filename)
      return __canvas_assets_loadSound(name, filename)
    end

    -- Create a named reference to a discovered music file
    -- Returns an asset handle that can be used with play_music
    -- Must be called before canvas.start()
    function _canvas.assets.load_music(name, filename)
      return __canvas_assets_loadMusic(name, filename)
    end

    -- Get asset dimensions (accepts string name or asset handle)
    function _canvas.assets.get_width(name)
      return __canvas_assets_getWidth(name)
    end

    function _canvas.assets.get_height(name)
      return __canvas_assets_getHeight(name)
    end

    -- Transformation functions
    function _canvas.translate(dx, dy)
      __canvas_translate(dx, dy)
    end

    function _canvas.rotate(angle)
      __canvas_rotate(angle)
    end

    function _canvas.scale(sx, sy)
      __canvas_scale(sx, sy)
    end

    function _canvas.save()
      __canvas_save()
    end

    function _canvas.restore()
      __canvas_restore()
    end

    function _canvas.transform(a, b, c, d, e, f)
      __canvas_transform(a, b, c, d, e, f)
    end

    function _canvas.set_transform(a, b, c, d, e, f)
      __canvas_setTransform(a, b, c, d, e, f)
    end

    function _canvas.reset_transform()
      __canvas_resetTransform()
    end

    -- Timing
    function _canvas.get_delta()
      return __canvas_getDelta()
    end

    function _canvas.get_time()
      return __canvas_getTime()
    end

    -- Capture canvas as data URL
    function _canvas.capture(options)
      local format = nil
      local quality = nil
      if options then
        if options.format then
          -- Convert short format names to MIME types
          if options.format == "png" then
            format = "image/png"
          elseif options.format == "jpeg" or options.format == "jpg" then
            format = "image/jpeg"
          elseif options.format == "webp" then
            format = "image/webp"
          else
            format = options.format
          end
        end
        quality = options.quality
      end
      return __canvas_capture(format, quality)
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/path.ts
  var canvasLuaPathCode = \`
    -- Path API
    function _canvas.begin_path()
      __canvas_beginPath()
    end

    function _canvas.close_path()
      __canvas_closePath()
    end

    function _canvas.move_to(x, y)
      __canvas_moveTo(x, y)
    end

    function _canvas.line_to(x, y)
      __canvas_lineTo(x, y)
    end

    function _canvas.fill()
      __canvas_fill()
    end

    function _canvas.stroke()
      __canvas_stroke()
    end

    function _canvas.arc(x, y, radius, startAngle, endAngle, counterclockwise)
      __canvas_arc(x, y, radius, startAngle, endAngle, counterclockwise or false)
    end

    function _canvas.arc_to(x1, y1, x2, y2, radius)
      __canvas_arcTo(x1, y1, x2, y2, radius)
    end

    function _canvas.quadratic_curve_to(cpx, cpy, x, y)
      __canvas_quadraticCurveTo(cpx, cpy, x, y)
    end

    function _canvas.bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y)
      __canvas_bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
    end

    function _canvas.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)
      __canvas_ellipse(x, y, radiusX, radiusY, rotation or 0, startAngle or 0, endAngle or (math.pi * 2), counterclockwise or false)
    end

    function _canvas.round_rect(x, y, width, height, radii)
      __canvas_roundRect(x, y, width, height, radii)
    end

    -- Add a rectangle to the current path (does not draw, use fill() or stroke() after)
    function _canvas.rect(x, y, width, height)
      __canvas_rectPath(x, y, width, height)
    end

    function _canvas.clip(fillRule)
      __canvas_clip(fillRule)
    end

    -- Hit Testing API
    function _canvas.is_point_in_path(x, y, fillRule)
      return __canvas_isPointInPath(x, y, fillRule or "nonzero")
    end

    function _canvas.is_point_in_stroke(x, y)
      return __canvas_isPointInStroke(x, y)
    end

    -- Pixel Manipulation API
    -- ImageData class for pixel-level access
    -- Uses JS-side storage for O(1) put_image_data performance
    local ImageData = {}
    ImageData.__index = ImageData

    function ImageData.new(jsInfo)
      local self = setmetatable({}, ImageData)
      self._jsId = jsInfo.id
      self.width = jsInfo.width
      self.height = jsInfo.height
      return self
    end

    function ImageData:get_pixel(x, y)
      local rgba = __canvas_imageDataGetPixel(self._jsId, x, y)
      return rgba[1], rgba[2], rgba[3], rgba[4]
    end

    function ImageData:set_pixel(x, y, r, g, b, a)
      __canvas_imageDataSetPixel(self._jsId, x, y, r, g, b, a or 255)
    end

    function _canvas.create_image_data(width, height)
      local info = __canvas_createImageData(width, height)
      return ImageData.new(info)
    end

    function _canvas.get_image_data(x, y, width, height)
      local info = __canvas_getImageData(x, y, width, height)
      if not info then return nil end
      return ImageData.new(info)
    end

    function _canvas.put_image_data(image_data, dx, dy, options)
      local dirtyX = nil
      local dirtyY = nil
      local dirtyWidth = nil
      local dirtyHeight = nil
      if options then
        dirtyX = options.dirty_x
        dirtyY = options.dirty_y
        dirtyWidth = options.dirty_width
        dirtyHeight = options.dirty_height
      end
      __canvas_putImageData(image_data._jsId, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)
    end

    function _canvas.clone_image_data(image_data)
      local info = __canvas_cloneImageData(image_data._jsId)
      if not info then return nil end
      return ImageData.new(info)
    end

    -- ==========================================================================
    -- Path2D API - Reusable path objects
    -- ==========================================================================

    -- Path2D class for reusable path objects
    local Path2D = {}
    Path2D.__index = Path2D

    function Path2D.new(jsInfo)
      local self = setmetatable({}, Path2D)
      self._jsId = jsInfo.id
      return self
    end

    -- Path building methods (all chainable, return self)
    function Path2D:move_to(x, y)
      __canvas_pathMoveTo(self._jsId, x, y)
      return self
    end

    function Path2D:line_to(x, y)
      __canvas_pathLineTo(self._jsId, x, y)
      return self
    end

    function Path2D:close_path()
      __canvas_pathClosePath(self._jsId)
      return self
    end

    function Path2D:rect(x, y, width, height)
      __canvas_pathRect(self._jsId, x, y, width, height)
      return self
    end

    function Path2D:round_rect(x, y, width, height, radii)
      __canvas_pathRoundRect(self._jsId, x, y, width, height, radii)
      return self
    end

    function Path2D:arc(x, y, radius, startAngle, endAngle, counterclockwise)
      __canvas_pathArc(self._jsId, x, y, radius, startAngle, endAngle, counterclockwise or false)
      return self
    end

    function Path2D:arc_to(x1, y1, x2, y2, radius)
      __canvas_pathArcTo(self._jsId, x1, y1, x2, y2, radius)
      return self
    end

    function Path2D:ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)
      __canvas_pathEllipse(self._jsId, x, y, radiusX, radiusY, rotation or 0, startAngle or 0, endAngle or (math.pi * 2), counterclockwise or false)
      return self
    end

    function Path2D:quadratic_curve_to(cpx, cpy, x, y)
      __canvas_pathQuadraticCurveTo(self._jsId, cpx, cpy, x, y)
      return self
    end

    function Path2D:bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y)
      __canvas_pathBezierCurveTo(self._jsId, cp1x, cp1y, cp2x, cp2y, x, y)
      return self
    end

    function Path2D:add_path(other_path)
      __canvas_pathAddPath(self._jsId, other_path._jsId)
      return self
    end

    -- Dispose method to free memory
    function Path2D:dispose()
      __canvas_disposePath(self._jsId)
    end

    -- Create a new Path2D object
    -- Can be created empty, from SVG path string, or by cloning another path
    function _canvas.create_path(arg)
      if type(arg) == "string" then
        -- SVG path string
        local info = __canvas_createPath(arg)
        if not info then return nil end
        return Path2D.new(info)
      elseif type(arg) == "table" and arg._jsId then
        -- Clone from another Path2D
        local info = __canvas_clonePath(arg._jsId)
        if not info then return nil end
        return Path2D.new(info)
      else
        -- Empty path (arg is nil or ignored)
        local info = __canvas_createPath(nil)
        if not info then return nil end
        return Path2D.new(info)
      end
    end

    -- Extend fill/stroke/clip to accept optional Path2D argument
    local _original_fill = _canvas.fill
    function _canvas.fill(path_or_fill_rule, fill_rule)
      if type(path_or_fill_rule) == "table" and path_or_fill_rule._jsId then
        -- Path2D object passed
        __canvas_fillPath(path_or_fill_rule._jsId, fill_rule)
      else
        -- Original behavior (no path, just fill rule)
        _original_fill()
      end
    end

    local _original_stroke = _canvas.stroke
    function _canvas.stroke(path)
      if type(path) == "table" and path._jsId then
        -- Path2D object passed
        __canvas_strokePath(path._jsId)
      else
        -- Original behavior
        _original_stroke()
      end
    end

    local _original_clip = _canvas.clip
    function _canvas.clip(path_or_fill_rule, fill_rule)
      if type(path_or_fill_rule) == "table" and path_or_fill_rule._jsId then
        -- Path2D object passed
        __canvas_clipPath(path_or_fill_rule._jsId, fill_rule)
      else
        -- Original behavior (no path, just fill rule)
        _original_clip(path_or_fill_rule)
      end
    end

    -- Extend hit testing to accept optional Path2D argument
    local _original_is_point_in_path = _canvas.is_point_in_path
    function _canvas.is_point_in_path(path_or_x, x_or_y, y_or_fill_rule, fill_rule)
      if type(path_or_x) == "table" and path_or_x._jsId then
        -- Path2D object passed: is_point_in_path(path, x, y, fillRule?)
        return __canvas_isPointInStoredPath(path_or_x._jsId, x_or_y, y_or_fill_rule, fill_rule or "nonzero")
      else
        -- Original behavior: is_point_in_path(x, y, fillRule?)
        return _original_is_point_in_path(path_or_x, x_or_y, y_or_fill_rule)
      end
    end

    local _original_is_point_in_stroke = _canvas.is_point_in_stroke
    function _canvas.is_point_in_stroke(path_or_x, x_or_y, y)
      if type(path_or_x) == "table" and path_or_x._jsId then
        -- Path2D object passed: is_point_in_stroke(path, x, y)
        return __canvas_isPointInStoredStroke(path_or_x._jsId, x_or_y, y)
      else
        -- Original behavior: is_point_in_stroke(x, y)
        return _original_is_point_in_stroke(path_or_x, x_or_y)
      end
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/styling.ts
  var canvasLuaStylingCode = \`
    -- Line Style API
    function _canvas.set_line_cap(cap)
      __canvas_setLineCap(cap)
    end

    function _canvas.set_line_join(join)
      __canvas_setLineJoin(join)
    end

    function _canvas.set_miter_limit(limit)
      __canvas_setMiterLimit(limit)
    end

    function _canvas.set_line_dash(segments)
      -- Convert Lua table to JS array
      local js_segments = {}
      for i, v in ipairs(segments or {}) do
        js_segments[i] = v
      end
      __canvas_setLineDash(js_segments)
    end

    function _canvas.get_line_dash()
      local js_array = __canvas_getLineDash()
      local t = {}
      for i = 1, #js_array do
        t[i] = js_array[i]
      end
      return t
    end

    function _canvas.set_line_dash_offset(offset)
      __canvas_setLineDashOffset(offset)
    end

    -- Gradient API
    -- Metatable for gradient objects with add_color_stop method
    local GradientMT = {
      __index = {
        add_color_stop = function(self, offset, color)
          table.insert(self.stops, {offset = offset, color = color})
          return self  -- Enable method chaining
        end
      }
    }

    function _canvas.create_linear_gradient(x0, y0, x1, y1)
      return setmetatable({
        type = "linear",
        x0 = x0, y0 = y0, x1 = x1, y1 = y1,
        stops = {}
      }, GradientMT)
    end

    function _canvas.create_radial_gradient(x0, y0, r0, x1, y1, r1)
      return setmetatable({
        type = "radial",
        x0 = x0, y0 = y0, r0 = r0,
        x1 = x1, y1 = y1, r1 = r1,
        stops = {}
      }, GradientMT)
    end

    function _canvas.create_conic_gradient(startAngle, x, y)
      return setmetatable({
        type = "conic",
        startAngle = startAngle,
        x = x, y = y,
        stops = {}
      }, GradientMT)
    end

    function _canvas.create_pattern(imageName, repetition)
      repetition = repetition or "repeat"
      return {
        type = "pattern",
        imageName = imageName,
        repetition = repetition
      }
    end

    function _canvas.set_fill_style(style)
      __canvas_setFillStyle(style)
    end

    function _canvas.set_stroke_style(style)
      __canvas_setStrokeStyle(style)
    end

    -- Shadows
    function _canvas.set_shadow_color(color)
      __canvas_setShadowColor(color)
    end

    function _canvas.set_shadow_blur(blur)
      __canvas_setShadowBlur(blur)
    end

    function _canvas.set_shadow_offset_x(offset)
      __canvas_setShadowOffsetX(offset)
    end

    function _canvas.set_shadow_offset_y(offset)
      __canvas_setShadowOffsetY(offset)
    end

    function _canvas.set_shadow(color, blur, offsetX, offsetY)
      __canvas_setShadow(color, blur or 0, offsetX or 0, offsetY or 0)
    end

    function _canvas.clear_shadow()
      __canvas_clearShadow()
    end

    -- Compositing
    function _canvas.set_global_alpha(alpha)
      __canvas_setGlobalAlpha(alpha)
    end

    function _canvas.set_composite_operation(operation)
      __canvas_setCompositeOperation(operation)
    end

    -- Image smoothing (anti-aliasing for scaled images)
    -- Disable for crisp pixel art, enable for smooth scaled images
    function _canvas.set_image_smoothing(enabled)
      __canvas_setImageSmoothing(enabled)
    end

    -- CSS Filter
    function _canvas.set_filter(filter)
      __canvas_setFilter(filter)
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/text.ts
  var canvasLuaTextCode = \`
    -- Text Alignment
    function _canvas.set_text_align(align)
      __canvas_setTextAlign(align)
    end

    function _canvas.set_text_baseline(baseline)
      __canvas_setTextBaseline(baseline)
    end

    -- Draw text outline (stroke only, no fill)
    function _canvas.stroke_text(x, y, text, options)
      local fontSize = nil
      local fontFamily = nil
      local maxWidth = nil
      if options then
        fontSize = options.font_size
        fontFamily = options.font_family
        maxWidth = options.max_width
      end
      __canvas_strokeText(x, y, text, fontSize, fontFamily, maxWidth)
    end

    -- Get comprehensive text metrics
    -- Returns a table with:
    --   width: total text width
    --   actual_bounding_box_left: distance from alignment point to left edge
    --   actual_bounding_box_right: distance from alignment point to right edge
    --   actual_bounding_box_ascent: distance from baseline to top
    --   actual_bounding_box_descent: distance from baseline to bottom
    --   font_bounding_box_ascent: font ascent (highest glyph)
    --   font_bounding_box_descent: font descent (lowest glyph)
    function _canvas.get_text_metrics(text)
      local metrics = __canvas_getTextMetrics(text)
      return {
        width = metrics.width,
        actual_bounding_box_left = metrics.actualBoundingBoxLeft,
        actual_bounding_box_right = metrics.actualBoundingBoxRight,
        actual_bounding_box_ascent = metrics.actualBoundingBoxAscent,
        actual_bounding_box_descent = metrics.actualBoundingBoxDescent,
        font_bounding_box_ascent = metrics.fontBoundingBoxAscent,
        font_bounding_box_descent = metrics.fontBoundingBoxDescent,
      }
    end

    -- Text Direction (RTL/LTR support)
    function _canvas.set_direction(direction)
      __canvas_setDirection(direction)
    end

    -- Draw text within a bounded rectangle with alignment and overflow options
    function _canvas.draw_label(x, y, width, height, text, options)
      options = options or {}
      local align_h = options.align_h or "center"
      local align_v = options.align_v or "middle"
      local overflow = options.overflow or "visible"
      local padding = options.padding or {}
      local wrap = options.wrap or false
      local line_height = options.line_height or 1.2
      local char_count = options.char_count  -- nil means show all

      -- Normalize padding to {left, top, right, bottom}
      local pad_left = padding.left or 0
      local pad_top = padding.top or 0
      local pad_right = padding.right or 0
      local pad_bottom = padding.bottom or 0

      -- Calculate inner bounds after padding
      local inner_x = x + pad_left
      local inner_y = y + pad_top
      local inner_w = width - pad_left - pad_right
      local inner_h = height - pad_top - pad_bottom

      -- Calculate horizontal text position based on alignment
      local text_x
      if align_h == "left" then
        text_x = inner_x
      elseif align_h == "right" then
        text_x = inner_x + inner_w
      else -- center
        text_x = inner_x + inner_w / 2
      end

      -- Map align_h to Canvas textAlign values
      local canvas_align
      if align_h == "left" then
        canvas_align = "left"
      elseif align_h == "right" then
        canvas_align = "right"
      else
        canvas_align = "center"
      end

      -- Save state
      _canvas.save()

      -- Apply clipping if overflow is hidden or ellipsis
      if overflow == "hidden" or overflow == "ellipsis" then
        _canvas.begin_path()
        _canvas.move_to(x, y)
        _canvas.line_to(x + width, y)
        _canvas.line_to(x + width, y + height)
        _canvas.line_to(x, y + height)
        _canvas.close_path()
        _canvas.clip()
      end

      _canvas.set_text_align(canvas_align)

      -- Get font size for line height calculation
      local font_size = __current_font_size or 16
      local actual_line_height = font_size * line_height

      -- Word wrap logic (always wrap based on full text for stable layout)
      local lines = {}
      if wrap and inner_w > 0 then
        -- Split text into words
        local words = {}
        for word in text:gmatch("%S+") do
          table.insert(words, word)
        end

        local current_line = ""
        for i, word in ipairs(words) do
          local test_line = current_line == "" and word or (current_line .. " " .. word)
          local test_width = _canvas.get_text_width(test_line)

          if test_width > inner_w and current_line ~= "" then
            table.insert(lines, current_line)
            current_line = word
          else
            current_line = test_line
          end
        end
        if current_line ~= "" then
          table.insert(lines, current_line)
        end
      else
        -- No wrapping - single line
        local display_text = text

        if overflow == "ellipsis" and inner_w > 0 then
          local text_width = _canvas.get_text_width(text)
          if text_width > inner_w then
            local ellipsis = "..."
            local ellipsis_width = _canvas.get_text_width(ellipsis)
            local available = inner_w - ellipsis_width

            if available > 0 then
              local truncated = ""
              for i = 1, #text do
                local test = text:sub(1, i)
                if _canvas.get_text_width(test) > available then
                  break
                end
                truncated = test
              end
              display_text = truncated .. ellipsis
            else
              display_text = ellipsis
            end
          end
        end

        table.insert(lines, display_text)
      end

      -- Calculate total text block height
      local total_height = #lines * actual_line_height

      -- Calculate starting Y position based on vertical alignment
      local start_y
      if align_v == "top" then
        start_y = inner_y + actual_line_height / 2
      elseif align_v == "bottom" then
        start_y = inner_y + inner_h - total_height + actual_line_height / 2
      else -- middle
        start_y = inner_y + (inner_h - total_height) / 2 + actual_line_height / 2
      end

      -- Draw each line, applying char_count limit if specified
      _canvas.set_text_baseline("middle")
      local chars_remaining = char_count  -- nil means unlimited
      for i, line in ipairs(lines) do
        local line_y = start_y + (i - 1) * actual_line_height

        if chars_remaining == nil then
          -- No limit, draw full line
          _canvas.draw_text(text_x, line_y, line)
        elseif chars_remaining > 0 then
          -- Apply character limit
          local line_to_draw = line:sub(1, chars_remaining)
          _canvas.draw_text(text_x, line_y, line_to_draw)
          chars_remaining = chars_remaining - #line - 1  -- -1 for space between lines
        end
        -- If chars_remaining <= 0, skip drawing this line
      end

      -- Restore state
      _canvas.restore()
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/input.ts
  var canvasLuaInputCode = \`
    -- Helper to normalize key names
    local function normalize_key(key)
      if type(key) ~= 'string' then return key end
      -- Single letter keys
      if #key == 1 and key:match('%a') then
        return 'Key' .. key:upper()
      end
      -- Arrow keys
      local arrows = { up = 'ArrowUp', down = 'ArrowDown', left = 'ArrowLeft', right = 'ArrowRight' }
      if arrows[key:lower()] then
        return arrows[key:lower()]
      end
      -- Space key
      if key:lower() == 'space' or key == ' ' then
        return 'Space'
      end
      -- Common keys
      local common = {
        enter = 'Enter', escape = 'Escape', esc = 'Escape',
        tab = 'Tab', shift = 'ShiftLeft', ctrl = 'ControlLeft',
        alt = 'AltLeft', backspace = 'Backspace'
      }
      if common[key:lower()] then
        return common[key:lower()]
      end
      return key
    end

    -- Keyboard input
    function _canvas.is_key_down(key)
      return __canvas_isKeyDown(normalize_key(key))
    end

    function _canvas.is_key_pressed(key)
      return __canvas_isKeyPressed(normalize_key(key))
    end

    -- Helper to convert JS array proxy to plain Lua table
    -- This ensures proper Lua errors with line numbers instead of JS TypeErrors
    local function to_lua_array(js_array)
      local t = {}
      for i = 1, #js_array do
        t[i] = js_array[i]
      end
      return t
    end

    function _canvas.get_keys_down()
      return to_lua_array(__canvas_getKeysDown())
    end

    function _canvas.get_keys_pressed()
      return to_lua_array(__canvas_getKeysPressed())
    end

    -- Mouse input
    function _canvas.get_mouse_x()
      return __canvas_getMouseX()
    end

    function _canvas.get_mouse_y()
      return __canvas_getMouseY()
    end

    function _canvas.is_mouse_down(button)
      return __canvas_isMouseDown(button)
    end

    function _canvas.is_mouse_pressed(button)
      return __canvas_isMousePressed(button)
    end

    -- Key constants for discoverability
    _canvas.keys = {
      -- Letters
      A = 'KeyA', B = 'KeyB', C = 'KeyC', D = 'KeyD', E = 'KeyE',
      F = 'KeyF', G = 'KeyG', H = 'KeyH', I = 'KeyI', J = 'KeyJ',
      K = 'KeyK', L = 'KeyL', M = 'KeyM', N = 'KeyN', O = 'KeyO',
      P = 'KeyP', Q = 'KeyQ', R = 'KeyR', S = 'KeyS', T = 'KeyT',
      U = 'KeyU', V = 'KeyV', W = 'KeyW', X = 'KeyX', Y = 'KeyY', Z = 'KeyZ',

      -- Number row
      ['0'] = 'Digit0', ['1'] = 'Digit1', ['2'] = 'Digit2', ['3'] = 'Digit3',
      ['4'] = 'Digit4', ['5'] = 'Digit5', ['6'] = 'Digit6', ['7'] = 'Digit7',
      ['8'] = 'Digit8', ['9'] = 'Digit9',
      DIGIT_0 = 'Digit0', DIGIT_1 = 'Digit1', DIGIT_2 = 'Digit2', DIGIT_3 = 'Digit3',
      DIGIT_4 = 'Digit4', DIGIT_5 = 'Digit5', DIGIT_6 = 'Digit6', DIGIT_7 = 'Digit7',
      DIGIT_8 = 'Digit8', DIGIT_9 = 'Digit9',

      -- Arrow keys
      UP = 'ArrowUp', DOWN = 'ArrowDown', LEFT = 'ArrowLeft', RIGHT = 'ArrowRight',
      ARROW_UP = 'ArrowUp', ARROW_DOWN = 'ArrowDown', ARROW_LEFT = 'ArrowLeft', ARROW_RIGHT = 'ArrowRight',

      -- Function keys
      F1 = 'F1', F2 = 'F2', F3 = 'F3', F4 = 'F4', F5 = 'F5', F6 = 'F6',
      F7 = 'F7', F8 = 'F8', F9 = 'F9', F10 = 'F10', F11 = 'F11', F12 = 'F12',

      -- Modifier keys
      SHIFT = 'ShiftLeft', SHIFT_LEFT = 'ShiftLeft', SHIFT_RIGHT = 'ShiftRight',
      CTRL = 'ControlLeft', CTRL_LEFT = 'ControlLeft', CTRL_RIGHT = 'ControlRight',
      CONTROL = 'ControlLeft', CONTROL_LEFT = 'ControlLeft', CONTROL_RIGHT = 'ControlRight',
      ALT = 'AltLeft', ALT_LEFT = 'AltLeft', ALT_RIGHT = 'AltRight',
      META = 'MetaLeft', META_LEFT = 'MetaLeft', META_RIGHT = 'MetaRight',
      CAPS_LOCK = 'CapsLock',

      -- Special keys
      SPACE = 'Space', ENTER = 'Enter', ESCAPE = 'Escape', TAB = 'Tab',
      BACKSPACE = 'Backspace', DELETE = 'Delete', INSERT = 'Insert',
      HOME = 'Home', END = 'End', PAGE_UP = 'PageUp', PAGE_DOWN = 'PageDown',
      PRINT_SCREEN = 'PrintScreen', SCROLL_LOCK = 'ScrollLock', PAUSE = 'Pause',
      NUM_LOCK = 'NumLock',

      -- Numpad keys
      NUMPAD_0 = 'Numpad0', NUMPAD_1 = 'Numpad1', NUMPAD_2 = 'Numpad2', NUMPAD_3 = 'Numpad3',
      NUMPAD_4 = 'Numpad4', NUMPAD_5 = 'Numpad5', NUMPAD_6 = 'Numpad6', NUMPAD_7 = 'Numpad7',
      NUMPAD_8 = 'Numpad8', NUMPAD_9 = 'Numpad9',
      NUMPAD_ADD = 'NumpadAdd', NUMPAD_SUBTRACT = 'NumpadSubtract',
      NUMPAD_MULTIPLY = 'NumpadMultiply', NUMPAD_DIVIDE = 'NumpadDivide',
      NUMPAD_DECIMAL = 'NumpadDecimal', NUMPAD_ENTER = 'NumpadEnter',

      -- Punctuation and symbols
      MINUS = 'Minus', EQUAL = 'Equal', BRACKET_LEFT = 'BracketLeft', BRACKET_RIGHT = 'BracketRight',
      BACKSLASH = 'Backslash', SEMICOLON = 'Semicolon', QUOTE = 'Quote',
      BACKQUOTE = 'Backquote', COMMA = 'Comma', PERIOD = 'Period', SLASH = 'Slash',

      -- Context menu key
      CONTEXT_MENU = 'ContextMenu',
    }

    -- Register canvas as a module so require('canvas') works
    -- Note: canvas is NOT a global - it must be accessed via require('canvas')
    package.preload['canvas'] = function()
      return _canvas
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/audio.ts
  var canvasLuaAudioCode = \`
    -- ========================================================================
    -- Audio API
    -- ========================================================================

    -- Sound effect playback (can overlap)
    function _canvas.play_sound(name, volume)
      __audio_playSound(name, volume)
    end

    -- Get the duration of a sound in seconds
    function _canvas.get_sound_duration(name)
      return __audio_getSoundDuration(name)
    end

    -- Music playback (one track at a time)
    function _canvas.play_music(name, options)
      local volume = 1
      local loop = false
      if options then
        if options.volume then volume = options.volume end
        if options.loop then loop = options.loop end
      end
      __audio_playMusic(name, volume, loop)
    end

    function _canvas.stop_music()
      __audio_stopMusic()
    end

    function _canvas.pause_music()
      __audio_pauseMusic()
    end

    function _canvas.resume_music()
      __audio_resumeMusic()
    end

    function _canvas.set_music_volume(volume)
      __audio_setMusicVolume(volume)
    end

    function _canvas.is_music_playing()
      return __audio_isMusicPlaying()
    end

    function _canvas.get_music_time()
      return __audio_getMusicTime()
    end

    function _canvas.get_music_duration()
      return __audio_getMusicDuration()
    end

    -- Global audio control
    function _canvas.set_master_volume(volume)
      __audio_setMasterVolume(volume)
    end

    function _canvas.get_master_volume()
      return __audio_getMasterVolume()
    end

    function _canvas.mute()
      __audio_mute()
    end

    function _canvas.unmute()
      __audio_unmute()
    end

    function _canvas.is_muted()
      return __audio_isMuted()
    end

    -- ========================================================================
    -- Audio Channel API
    -- ========================================================================

    function _canvas.channel_create(name, options)
      local parent = nil
      if options and options.parent then
        parent = options.parent
      end
      __audio_channelCreate(name, parent)
    end

    function _canvas.channel_get_parent(name)
      return __audio_channelGetParent(name)
    end

    function _canvas.channel_set_parent(name, parent)
      __audio_channelSetParent(name, parent)
    end

    function _canvas.channel_get_effective_volume(name)
      return __audio_channelGetEffectiveVolume(name)
    end

    function _canvas.channel_destroy(name)
      __audio_channelDestroy(name)
    end

    function _canvas.channel_play(channel, audio, options)
      local volume = 1
      local loop = false
      local start_time = 0
      if options then
        if options.volume then volume = options.volume end
        if options.loop then loop = options.loop end
        if options.start_time then start_time = options.start_time end
      end
      __audio_channelPlay(channel, audio, volume, loop, start_time)
    end

    function _canvas.channel_stop(channel)
      __audio_channelStop(channel)
    end

    function _canvas.channel_pause(channel)
      __audio_channelPause(channel)
    end

    function _canvas.channel_resume(channel)
      __audio_channelResume(channel)
    end

    function _canvas.channel_set_volume(channel, volume)
      __audio_channelSetVolume(channel, volume)
    end

    function _canvas.channel_get_volume(channel)
      return __audio_channelGetVolume(channel)
    end

    function _canvas.channel_fade_to(channel, targetVolume, duration)
      __audio_channelFadeTo(channel, targetVolume, duration)
    end

    function _canvas.channel_is_playing(channel)
      return __audio_channelIsPlaying(channel)
    end

    function _canvas.channel_is_fading(channel)
      return __audio_channelIsFading(channel)
    end

    function _canvas.channel_get_time(channel)
      return __audio_channelGetTime(channel)
    end

    function _canvas.channel_get_duration(channel)
      return __audio_channelGetDuration(channel)
    end

    function _canvas.channel_get_audio(channel)
      return __audio_channelGetAudio(channel)
    end
\`;

  // ../lua-runtime/src/audio/WebAudioEngine.ts
  var WebAudioEngine = class {
    constructor() {
      __publicField(this, "audioContext", null);
      __publicField(this, "masterGainNode", null);
      __publicField(this, "audioBuffers", /* @__PURE__ */ new Map());
      __publicField(this, "musicState", null);
      __publicField(this, "channels", /* @__PURE__ */ new Map());
      __publicField(this, "masterVolume", 1);
      __publicField(this, "muted", false);
      __publicField(this, "initialized", false);
      /** Promise for in-progress initialization to prevent race conditions */
      __publicField(this, "initializePromise", null);
    }
    /**
     * Initialize the audio engine.
     * Creates the AudioContext and master gain node.
     * Uses a promise to prevent race conditions from concurrent calls.
     */
    async initialize() {
      if (this.initialized) {
        return;
      }
      if (this.initializePromise) {
        return this.initializePromise;
      }
      this.initializePromise = this.doInitialize();
      try {
        await this.initializePromise;
      } finally {
        this.initializePromise = null;
      }
    }
    /**
     * Internal initialization logic.
     */
    async doInitialize() {
      this.audioContext = new AudioContext();
      this.masterGainNode = this.audioContext.createGain();
      this.masterGainNode.connect(this.audioContext.destination);
      this.masterGainNode.gain.value = this.masterVolume;
      if (this.audioContext.state === "suspended") {
        await this.audioContext.resume();
      }
      this.initialized = true;
    }
    /**
     * Check if the audio engine is initialized.
     */
    isInitialized() {
      return this.initialized;
    }
    /**
     * Decode audio data and store it by name.
     */
    async decodeAudio(name, data) {
      if (!this.audioContext) {
        throw new Error("Audio engine not initialized");
      }
      const audioBuffer = await this.audioContext.decodeAudioData(data);
      this.audioBuffers.set(name, audioBuffer);
    }
    /**
     * Check if an audio asset has been loaded.
     */
    hasAudio(name) {
      return this.audioBuffers.has(name);
    }
    /**
     * Play a sound effect.
     */
    playSound(name, volume = 1) {
      if (!this.audioContext || !this.masterGainNode) {
        return;
      }
      const buffer = this.audioBuffers.get(name);
      if (!buffer) {
        console.warn(\`Sound not found: \${name}\`);
        return;
      }
      const source = this.audioContext.createBufferSource();
      const gainNode = this.audioContext.createGain();
      source.buffer = buffer;
      const effectiveVolume = this.muted ? 0 : volume;
      gainNode.gain.value = effectiveVolume;
      source.connect(gainNode);
      gainNode.connect(this.masterGainNode);
      source.start(0);
    }
    /**
     * Get the duration of a sound in seconds.
     */
    getSoundDuration(name) {
      const buffer = this.audioBuffers.get(name);
      return buffer?.duration ?? 0;
    }
    /**
     * Play background music.
     */
    playMusic(name, options) {
      if (!this.audioContext || !this.masterGainNode) {
        return null;
      }
      const buffer = this.audioBuffers.get(name);
      if (!buffer) {
        console.warn(\`Music not found: \${name}\`);
        return null;
      }
      this.stopMusicInternal();
      const volume = options?.volume ?? 1;
      const loop = options?.loop ?? false;
      const gainNode = this.audioContext.createGain();
      const effectiveVolume = this.muted ? 0 : volume * this.masterVolume;
      gainNode.gain.value = effectiveVolume;
      gainNode.connect(this.masterGainNode);
      const source = this.audioContext.createBufferSource();
      source.buffer = buffer;
      source.loop = loop;
      source.connect(gainNode);
      source.onended = () => {
        if (this.musicState?.source === source) {
          this.musicState.isPlaying = false;
        }
      };
      this.musicState = {
        buffer,
        source,
        gainNode,
        isPlaying: true,
        startTime: this.audioContext.currentTime,
        pausedAt: 0,
        loop,
        volume
      };
      source.start(0);
      return this.createMusicHandle();
    }
    /**
     * Create a MusicHandle for the current music.
     */
    createMusicHandle() {
      return {
        stop: () => this.stopMusic(),
        pause: () => this.pauseMusic(),
        resume: () => this.resumeMusic(),
        setVolume: (v) => this.setMusicVolume(v),
        getVolume: () => this.musicState?.volume ?? 0,
        isPlaying: () => this.isMusicPlaying(),
        getCurrentTime: () => this.getMusicTime(),
        getDuration: () => this.getMusicDuration()
      };
    }
    /**
     * Stop music playback (internal).
     */
    stopMusicInternal() {
      if (this.musicState?.source) {
        try {
          this.musicState.source.stop();
        } catch {
        }
        this.musicState.source.disconnect();
      }
      if (this.musicState?.gainNode) {
        this.musicState.gainNode.disconnect();
      }
      this.musicState = null;
    }
    /**
     * Stop the currently playing music.
     */
    stopMusic() {
      this.stopMusicInternal();
    }
    /**
     * Pause the currently playing music.
     */
    pauseMusic() {
      if (!this.musicState || !this.musicState.isPlaying || !this.audioContext) {
        return;
      }
      const elapsed = this.audioContext.currentTime - this.musicState.startTime;
      this.musicState.pausedAt = elapsed % this.musicState.buffer.duration;
      this.musicState.isPlaying = false;
      if (this.musicState.source) {
        try {
          this.musicState.source.stop();
        } catch {
        }
        this.musicState.source.disconnect();
        this.musicState.source = null;
      }
    }
    /**
     * Resume paused music.
     */
    resumeMusic() {
      if (!this.musicState || this.musicState.isPlaying || !this.audioContext) {
        return;
      }
      const source = this.audioContext.createBufferSource();
      source.buffer = this.musicState.buffer;
      source.loop = this.musicState.loop;
      source.connect(this.musicState.gainNode);
      source.onended = () => {
        if (this.musicState?.source === source) {
          this.musicState.isPlaying = false;
        }
      };
      this.musicState.source = source;
      this.musicState.isPlaying = true;
      this.musicState.startTime = this.audioContext.currentTime - this.musicState.pausedAt;
      source.start(0, this.musicState.pausedAt);
    }
    /**
     * Set the volume of the currently playing music.
     */
    setMusicVolume(volume) {
      if (!this.musicState) {
        return;
      }
      this.musicState.volume = Math.max(0, Math.min(1, volume));
      const effectiveVolume = this.muted ? 0 : this.musicState.volume * this.masterVolume;
      this.musicState.gainNode.gain.value = effectiveVolume;
    }
    /**
     * Check if music is currently playing.
     */
    isMusicPlaying() {
      return this.musicState?.isPlaying ?? false;
    }
    /**
     * Get the current music playback time in seconds.
     */
    getMusicTime() {
      if (!this.musicState || !this.audioContext) {
        return 0;
      }
      if (!this.musicState.isPlaying) {
        return this.musicState.pausedAt;
      }
      const elapsed = this.audioContext.currentTime - this.musicState.startTime;
      return elapsed % this.musicState.buffer.duration;
    }
    /**
     * Get the total duration of the current music in seconds.
     */
    getMusicDuration() {
      return this.musicState?.buffer.duration ?? 0;
    }
    /**
     * Set the master volume that affects all audio.
     */
    setMasterVolume(volume) {
      this.masterVolume = Math.max(0, Math.min(1, volume));
      if (this.masterGainNode && !this.muted) {
        this.masterGainNode.gain.value = this.masterVolume;
      }
      if (this.musicState && !this.muted) {
        this.musicState.gainNode.gain.value = this.musicState.volume * this.masterVolume;
      }
    }
    /**
     * Get the current master volume.
     */
    getMasterVolume() {
      return this.masterVolume;
    }
    /**
     * Mute all audio.
     */
    mute() {
      this.muted = true;
      if (this.masterGainNode) {
        this.masterGainNode.gain.value = 0;
      }
      if (this.musicState) {
        this.musicState.gainNode.gain.value = 0;
      }
    }
    /**
     * Unmute all audio.
     */
    unmute() {
      this.muted = false;
      if (this.masterGainNode) {
        this.masterGainNode.gain.value = this.masterVolume;
      }
      if (this.musicState) {
        this.musicState.gainNode.gain.value = this.musicState.volume * this.masterVolume;
      }
    }
    /**
     * Check if audio is muted.
     */
    isMuted() {
      return this.muted;
    }
    /**
     * Clean up all resources.
     */
    dispose() {
      this.stopMusicInternal();
      for (const [name] of this.channels) {
        this.destroyChannel(name);
      }
      this.channels.clear();
      this.audioBuffers.clear();
      if (this.audioContext && this.audioContext.state !== "closed") {
        this.audioContext.close().catch(() => {
        });
      }
      this.audioContext = null;
      this.masterGainNode = null;
      this.initialized = false;
      this.initializePromise = null;
    }
    // --- Channel API ---
    createChannel(name, parentName) {
      if (!this.audioContext || !this.masterGainNode || this.channels.has(name)) {
        return;
      }
      const parentGain = parentName ? this.channels.get(parentName)?.gainNode ?? this.masterGainNode : this.masterGainNode;
      const gainNode = this.audioContext.createGain();
      gainNode.connect(parentGain);
      this.channels.set(name, {
        gainNode,
        source: null,
        buffer: null,
        isPlaying: false,
        volume: 1,
        loop: false,
        currentAudioName: "",
        startTime: 0,
        pausedAt: 0,
        isFading: false,
        fadeTargetVolume: 1,
        fadeStartTime: 0,
        fadeDuration: 0,
        parentName: parentName ?? null
      });
    }
    getChannelParent(name) {
      return this.channels.get(name)?.parentName ?? null;
    }
    setChannelParent(name, parentName) {
      const state = this.channels.get(name);
      if (!state || !this.masterGainNode) return;
      const newParent = parentName ? this.channels.get(parentName)?.gainNode ?? this.masterGainNode : this.masterGainNode;
      state.gainNode.disconnect();
      state.gainNode.connect(newParent);
      state.parentName = parentName;
    }
    getEffectiveVolume(name) {
      let volume = 1;
      let currentName = name;
      while (currentName) {
        const state = this.channels.get(currentName);
        if (!state) break;
        volume *= state.volume;
        currentName = state.parentName;
      }
      return volume * this.masterVolume;
    }
    destroyChannel(name) {
      const state = this.channels.get(name);
      if (!state) return;
      if (state.source) {
        try {
          state.source.stop();
        } catch {
        }
        state.source.disconnect();
      }
      state.gainNode.disconnect();
      this.channels.delete(name);
    }
    playOnChannel(channel, audioName, volume = 1, loop = false, startTime = 0) {
      if (!this.channels.has(channel)) {
        this.createChannel(channel);
      }
      const state = this.channels.get(channel);
      if (!state || !this.audioContext) return;
      const buffer = this.audioBuffers.get(audioName);
      if (!buffer) {
        console.warn(\`Audio not found: \${audioName}\`);
        return;
      }
      if (state.source) {
        try {
          state.source.stop();
        } catch {
        }
        state.source.disconnect();
      }
      const normalizedStartTime = loop ? startTime % buffer.duration : Math.min(startTime, buffer.duration);
      const source = this.audioContext.createBufferSource();
      source.buffer = buffer;
      source.loop = loop;
      source.connect(state.gainNode);
      source.onended = () => {
        if (state.source === source) {
          state.isPlaying = false;
        }
      };
      state.gainNode.gain.value = volume;
      state.source = source;
      state.buffer = buffer;
      state.isPlaying = true;
      state.volume = volume;
      state.loop = loop;
      state.currentAudioName = audioName;
      state.startTime = this.audioContext.currentTime - normalizedStartTime;
      state.pausedAt = 0;
      source.start(0, normalizedStartTime);
    }
    stopChannel(channel) {
      const state = this.channels.get(channel);
      if (!state) return;
      if (state.source) {
        try {
          state.source.stop();
        } catch {
        }
        state.source.disconnect();
        state.source = null;
      }
      state.isPlaying = false;
      state.currentAudioName = "";
      state.buffer = null;
    }
    pauseChannel(channel) {
      const state = this.channels.get(channel);
      if (!state || !state.isPlaying || !this.audioContext) return;
      const elapsed = this.audioContext.currentTime - state.startTime;
      state.pausedAt = state.buffer ? elapsed % state.buffer.duration : 0;
      state.isPlaying = false;
      if (state.source) {
        try {
          state.source.stop();
        } catch {
        }
        state.source.disconnect();
        state.source = null;
      }
    }
    resumeChannel(channel) {
      const state = this.channels.get(channel);
      if (!state || state.isPlaying || !state.buffer || !this.audioContext) return;
      const source = this.audioContext.createBufferSource();
      source.buffer = state.buffer;
      source.loop = state.loop;
      source.connect(state.gainNode);
      source.onended = () => {
        if (state.source === source) {
          state.isPlaying = false;
        }
      };
      state.source = source;
      state.isPlaying = true;
      state.startTime = this.audioContext.currentTime - state.pausedAt;
      source.start(0, state.pausedAt);
    }
    setChannelVolume(channel, volume) {
      const state = this.channels.get(channel);
      if (!state) return;
      state.volume = Math.max(0, Math.min(1, volume));
      state.gainNode.gain.value = state.volume;
    }
    getChannelVolume(channel) {
      return this.channels.get(channel)?.volume ?? 0;
    }
    fadeChannelTo(channel, targetVolume, duration) {
      const state = this.channels.get(channel);
      if (!state || !this.audioContext) return;
      const now = this.audioContext.currentTime;
      state.gainNode.gain.cancelScheduledValues(now);
      state.gainNode.gain.setValueAtTime(state.gainNode.gain.value, now);
      state.gainNode.gain.linearRampToValueAtTime(targetVolume, now + duration);
      state.isFading = true;
      state.fadeStartTime = now;
      state.fadeDuration = duration;
      state.fadeTargetVolume = targetVolume;
      state.volume = targetVolume;
      setTimeout(() => {
        if (state.fadeStartTime === now) {
          state.isFading = false;
        }
      }, duration * 1e3);
    }
    isChannelPlaying(channel) {
      return this.channels.get(channel)?.isPlaying ?? false;
    }
    isChannelFading(channel) {
      return this.channels.get(channel)?.isFading ?? false;
    }
    getChannelTime(channel) {
      const state = this.channels.get(channel);
      if (!state || !this.audioContext) return 0;
      if (!state.isPlaying) {
        return state.pausedAt;
      }
      const elapsed = this.audioContext.currentTime - state.startTime;
      return state.buffer ? elapsed % state.buffer.duration : 0;
    }
    getChannelDuration(channel) {
      return this.channels.get(channel)?.buffer?.duration ?? 0;
    }
    getChannelAudio(channel) {
      return this.channels.get(channel)?.currentAudioName ?? "";
    }
  };

  // src/runtime/canvas-standalone.ts
  var canvasLuaCode = canvasLuaCoreCode + canvasLuaPathCode + canvasLuaStylingCode + canvasLuaTextCode + canvasLuaInputCode + canvasLuaAudioCode;
  function createCanvasRuntimeState(canvas) {
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) {
      throw new Error("Could not get 2D rendering context");
    }
    return {
      canvas,
      ctx,
      isRunning: false,
      tickCallback: null,
      lastFrameTime: 0,
      deltaTime: 0,
      totalTime: 0,
      keysDown: /* @__PURE__ */ new Set(),
      keysPressed: /* @__PURE__ */ new Set(),
      mouseX: 0,
      mouseY: 0,
      mouseButtonsDown: /* @__PURE__ */ new Set(),
      mouseButtonsPressed: /* @__PURE__ */ new Set(),
      currentFontSize: 16,
      currentFontFamily: "monospace",
      stopResolve: null,
      audioEngine: new WebAudioEngine(),
      audioAssets: /* @__PURE__ */ new Map()
    };
  }
  function setupInputListeners(state) {
    const handleKeyDown = (e) => {
      if (!state.keysDown.has(e.code)) {
        state.keysPressed.add(e.code);
      }
      state.keysDown.add(e.code);
    };
    const handleKeyUp = (e) => {
      state.keysDown.delete(e.code);
    };
    const handleMouseMove = (e) => {
      const rect = state.canvas.getBoundingClientRect();
      const displayX = e.clientX - rect.left;
      const displayY = e.clientY - rect.top;
      state.mouseX = displayX * (state.canvas.width / rect.width);
      state.mouseY = displayY * (state.canvas.height / rect.height);
    };
    const handleMouseDown = (e) => {
      if (!state.mouseButtonsDown.has(e.button)) {
        state.mouseButtonsPressed.add(e.button);
      }
      state.mouseButtonsDown.add(e.button);
    };
    const handleMouseUp = (e) => {
      state.mouseButtonsDown.delete(e.button);
    };
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
    state.canvas.addEventListener("mousemove", handleMouseMove);
    state.canvas.addEventListener("mousedown", handleMouseDown);
    state.canvas.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
      state.canvas.removeEventListener("mousemove", handleMouseMove);
      state.canvas.removeEventListener("mousedown", handleMouseDown);
      state.canvas.removeEventListener("mouseup", handleMouseUp);
    };
  }
  function startGameLoop(state) {
    state.lastFrameTime = performance.now();
    function gameLoop(timestamp) {
      if (!state.isRunning) return;
      state.deltaTime = (timestamp - state.lastFrameTime) / 1e3;
      state.lastFrameTime = timestamp;
      state.totalTime += state.deltaTime;
      if (state.tickCallback) {
        try {
          state.tickCallback();
        } catch (err) {
          console.error("Lua error in tick callback:", err);
          state.isRunning = false;
          if (state.stopResolve) {
            state.stopResolve();
            state.stopResolve = null;
          }
          return;
        }
      }
      state.keysPressed.clear();
      state.mouseButtonsPressed.clear();
      if (state.isRunning) {
        requestAnimationFrame(gameLoop);
      }
    }
    requestAnimationFrame(gameLoop);
  }
  function toHex(value) {
    const hex = Math.max(0, Math.min(255, Math.round(value))).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }
  function colorToCss(r, g, b, a) {
    if (a !== void 0 && a !== null && a !== 255) {
      return \`rgba(\${r}, \${g}, \${b}, \${a / 255})\`;
    }
    return \`#\${toHex(r)}\${toHex(g)}\${toHex(b)}\`;
  }
  function setupCanvasBridge(engine, state) {
    const { ctx, canvas } = state;
    ctx.font = \`\${state.currentFontSize}px \${state.currentFontFamily}\`;
    ctx.textBaseline = "top";
    engine.global.set("__canvas_is_active", () => state.isRunning);
    engine.global.set("__canvas_start", async () => {
      await state.audioEngine.initialize();
      return new Promise((resolve) => {
        state.isRunning = true;
        state.stopResolve = resolve;
        startGameLoop(state);
      });
    });
    engine.global.set("__canvas_stop", () => {
      state.isRunning = false;
      if (state.stopResolve) {
        state.stopResolve();
        state.stopResolve = null;
      }
    });
    engine.global.set(
      "__canvas_setOnDrawCallback",
      (callback) => {
        state.tickCallback = callback;
      }
    );
    engine.global.set("__canvas_setSize", (width, height) => {
      canvas.width = width;
      canvas.height = height;
    });
    engine.global.set("__canvas_getWidth", () => canvas.width);
    engine.global.set("__canvas_getHeight", () => canvas.height);
    engine.global.set("__canvas_clear", () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
    engine.global.set(
      "__canvas_clearRect",
      (x, y, width, height) => {
        ctx.clearRect(x, y, width, height);
      }
    );
    engine.global.set(
      "__canvas_setColor",
      (r, g, b, a) => {
        const color = colorToCss(r, g, b, a);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
      }
    );
    engine.global.set("__canvas_setLineWidth", (width) => {
      ctx.lineWidth = width;
    });
    engine.global.set("__canvas_setFontSize", (size) => {
      state.currentFontSize = size;
      ctx.font = \`\${state.currentFontSize}px \${state.currentFontFamily}\`;
    });
    engine.global.set("__canvas_setFontFamily", (family) => {
      state.currentFontFamily = family;
      ctx.font = \`\${state.currentFontSize}px \${state.currentFontFamily}\`;
    });
    engine.global.set("__canvas_getTextWidth", (text) => {
      return ctx.measureText(text).width;
    });
    engine.global.set(
      "__canvas_rect",
      (x, y, width, height) => {
        ctx.strokeRect(x, y, width, height);
      }
    );
    engine.global.set(
      "__canvas_fillRect",
      (x, y, width, height) => {
        ctx.fillRect(x, y, width, height);
      }
    );
    engine.global.set(
      "__canvas_circle",
      (x, y, radius) => {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    );
    engine.global.set(
      "__canvas_fillCircle",
      (x, y, radius) => {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    );
    engine.global.set(
      "__canvas_line",
      (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    );
    engine.global.set(
      "__canvas_text",
      (x, y, text, fontSize, fontFamily, maxWidth) => {
        const savedFont = ctx.font;
        if (fontSize || fontFamily) {
          const size = fontSize ?? state.currentFontSize;
          const family = fontFamily ?? state.currentFontFamily;
          ctx.font = \`\${size}px \${family}\`;
        }
        if (maxWidth) {
          ctx.fillText(text, x, y, maxWidth);
        } else {
          ctx.fillText(text, x, y);
        }
        ctx.font = savedFont;
      }
    );
    engine.global.set(
      "__canvas_strokeText",
      (x, y, text, fontSize, fontFamily, maxWidth) => {
        const savedFont = ctx.font;
        if (fontSize || fontFamily) {
          const size = fontSize ?? state.currentFontSize;
          const family = fontFamily ?? state.currentFontFamily;
          ctx.font = \`\${size}px \${family}\`;
        }
        if (maxWidth) {
          ctx.strokeText(text, x, y, maxWidth);
        } else {
          ctx.strokeText(text, x, y);
        }
        ctx.font = savedFont;
      }
    );
    engine.global.set("__canvas_getDelta", () => state.deltaTime);
    engine.global.set("__canvas_getTime", () => state.totalTime);
    engine.global.set(
      "__canvas_isKeyDown",
      (key) => state.keysDown.has(key)
    );
    engine.global.set(
      "__canvas_isKeyPressed",
      (key) => state.keysPressed.has(key)
    );
    engine.global.set("__canvas_getKeysDown", () => Array.from(state.keysDown));
    engine.global.set(
      "__canvas_getKeysPressed",
      () => Array.from(state.keysPressed)
    );
    engine.global.set("__canvas_getMouseX", () => state.mouseX);
    engine.global.set("__canvas_getMouseY", () => state.mouseY);
    engine.global.set(
      "__canvas_isMouseDown",
      (button) => state.mouseButtonsDown.has(button)
    );
    engine.global.set(
      "__canvas_isMousePressed",
      (button) => state.mouseButtonsPressed.has(button)
    );
    engine.global.set("__canvas_translate", (dx, dy) => {
      ctx.translate(dx, dy);
    });
    engine.global.set("__canvas_rotate", (angle) => {
      ctx.rotate(angle);
    });
    engine.global.set("__canvas_scale", (sx, sy) => {
      ctx.scale(sx, sy);
    });
    engine.global.set("__canvas_save", () => {
      ctx.save();
    });
    engine.global.set("__canvas_restore", () => {
      ctx.restore();
    });
    engine.global.set(
      "__canvas_transform",
      (a, b, c, d, e, f) => {
        ctx.transform(a, b, c, d, e, f);
      }
    );
    engine.global.set(
      "__canvas_setTransform",
      (a, b, c, d, e, f) => {
        ctx.setTransform(a, b, c, d, e, f);
      }
    );
    engine.global.set("__canvas_resetTransform", () => {
      ctx.resetTransform();
    });
    engine.global.set("__canvas_beginPath", () => {
      ctx.beginPath();
    });
    engine.global.set("__canvas_closePath", () => {
      ctx.closePath();
    });
    engine.global.set("__canvas_moveTo", (x, y) => {
      ctx.moveTo(x, y);
    });
    engine.global.set("__canvas_lineTo", (x, y) => {
      ctx.lineTo(x, y);
    });
    engine.global.set("__canvas_fill", () => {
      ctx.fill();
    });
    engine.global.set("__canvas_stroke", () => {
      ctx.stroke();
    });
    engine.global.set(
      "__canvas_arc",
      (x, y, radius, startAngle, endAngle, counterclockwise) => {
        ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise);
      }
    );
    engine.global.set(
      "__canvas_arcTo",
      (x1, y1, x2, y2, radius) => {
        ctx.arcTo(x1, y1, x2, y2, radius);
      }
    );
    engine.global.set(
      "__canvas_quadraticCurveTo",
      (cpx, cpy, x, y) => {
        ctx.quadraticCurveTo(cpx, cpy, x, y);
      }
    );
    engine.global.set(
      "__canvas_bezierCurveTo",
      (cp1x, cp1y, cp2x, cp2y, x, y) => {
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      }
    );
    engine.global.set(
      "__canvas_ellipse",
      (x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) => {
        ctx.ellipse(
          x,
          y,
          radiusX,
          radiusY,
          rotation,
          startAngle,
          endAngle,
          counterclockwise
        );
      }
    );
    engine.global.set(
      "__canvas_roundRect",
      (x, y, width, height, radii) => {
        ctx.roundRect(x, y, width, height, radii);
      }
    );
    engine.global.set(
      "__canvas_rectPath",
      (x, y, width, height) => {
        ctx.rect(x, y, width, height);
      }
    );
    engine.global.set("__canvas_clip", (fillRule) => {
      if (fillRule) {
        ctx.clip(fillRule);
      } else {
        ctx.clip();
      }
    });
    engine.global.set(
      "__canvas_isPointInPath",
      (x, y, fillRule) => {
        return ctx.isPointInPath(x, y, fillRule);
      }
    );
    engine.global.set(
      "__canvas_isPointInStroke",
      (x, y) => {
        return ctx.isPointInStroke(x, y);
      }
    );
    engine.global.set("__canvas_setLineCap", (cap) => {
      ctx.lineCap = cap;
    });
    engine.global.set("__canvas_setLineJoin", (join) => {
      ctx.lineJoin = join;
    });
    engine.global.set("__canvas_setMiterLimit", (limit) => {
      ctx.miterLimit = limit;
    });
    engine.global.set("__canvas_setLineDash", (segments) => {
      ctx.setLineDash(segments);
    });
    engine.global.set("__canvas_getLineDash", () => {
      return ctx.getLineDash();
    });
    engine.global.set("__canvas_setLineDashOffset", (offset) => {
      ctx.lineDashOffset = offset;
    });
    engine.global.set("__canvas_setShadowColor", (color) => {
      ctx.shadowColor = color;
    });
    engine.global.set("__canvas_setShadowBlur", (blur) => {
      ctx.shadowBlur = blur;
    });
    engine.global.set("__canvas_setShadowOffsetX", (offset) => {
      ctx.shadowOffsetX = offset;
    });
    engine.global.set("__canvas_setShadowOffsetY", (offset) => {
      ctx.shadowOffsetY = offset;
    });
    engine.global.set(
      "__canvas_setShadow",
      (color, blur, offsetX, offsetY) => {
        ctx.shadowColor = color;
        ctx.shadowBlur = blur;
        ctx.shadowOffsetX = offsetX;
        ctx.shadowOffsetY = offsetY;
      }
    );
    engine.global.set("__canvas_clearShadow", () => {
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    });
    engine.global.set("__canvas_setGlobalAlpha", (alpha) => {
      ctx.globalAlpha = alpha;
    });
    engine.global.set(
      "__canvas_setCompositeOperation",
      (operation) => {
        ctx.globalCompositeOperation = operation;
      }
    );
    engine.global.set("__canvas_setImageSmoothing", (enabled) => {
      ctx.imageSmoothingEnabled = enabled;
    });
    engine.global.set("__canvas_setFilter", (filter) => {
      ctx.filter = filter;
    });
    engine.global.set("__canvas_setTextAlign", (align) => {
      ctx.textAlign = align;
    });
    engine.global.set(
      "__canvas_setTextBaseline",
      (baseline) => {
        ctx.textBaseline = baseline;
      }
    );
    engine.global.set(
      "__canvas_setDirection",
      (direction) => {
        ctx.direction = direction;
      }
    );
    engine.global.set("__canvas_getTextMetrics", (text) => {
      const metrics = ctx.measureText(text);
      return {
        width: metrics.width,
        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,
        actualBoundingBoxRight: metrics.actualBoundingBoxRight,
        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
        fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
        fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
      };
    });
    engine.global.set(
      "__canvas_capture",
      (format, quality) => {
        if (format && quality !== void 0 && quality !== null) {
          return canvas.toDataURL(format, quality);
        } else if (format) {
          return canvas.toDataURL(format);
        }
        return canvas.toDataURL();
      }
    );
    engine.global.set(
      "__canvas_setFillStyle",
      (style) => {
        if (typeof style === "string") {
          ctx.fillStyle = style;
        } else if (style.type === "linear") {
          const gradient = ctx.createLinearGradient(
            style.x0,
            style.y0,
            style.x1,
            style.y1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
        } else if (style.type === "radial") {
          const gradient = ctx.createRadialGradient(
            style.x0,
            style.y0,
            style.r0,
            style.x1,
            style.y1,
            style.r1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
        } else if (style.type === "conic") {
          const gradient = ctx.createConicGradient(
            style.startAngle,
            style.x,
            style.y
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
        }
      }
    );
    engine.global.set(
      "__canvas_setStrokeStyle",
      (style) => {
        if (typeof style === "string") {
          ctx.strokeStyle = style;
        } else if (style.type === "linear") {
          const gradient = ctx.createLinearGradient(
            style.x0,
            style.y0,
            style.x1,
            style.y1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.strokeStyle = gradient;
        } else if (style.type === "radial") {
          const gradient = ctx.createRadialGradient(
            style.x0,
            style.y0,
            style.r0,
            style.x1,
            style.y1,
            style.r1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.strokeStyle = gradient;
        } else if (style.type === "conic") {
          const gradient = ctx.createConicGradient(
            style.startAngle,
            style.x,
            style.y
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.strokeStyle = gradient;
        }
      }
    );
    engine.global.set("__canvas_assets_addPath", () => {
    });
    engine.global.set(
      "__canvas_assets_loadImage",
      (name, filename) => {
        return { _type: "image", _name: name, _file: filename };
      }
    );
    engine.global.set(
      "__canvas_assets_loadFont",
      (name, filename) => {
        return { _type: "font", _name: name, _file: filename };
      }
    );
    engine.global.set("__canvas_assets_getWidth", () => 0);
    engine.global.set("__canvas_assets_getHeight", () => 0);
    engine.global.set(
      "__canvas_drawImage",
      () => {
        console.warn("draw_image not fully supported in standalone export");
      }
    );
    engine.global.set(
      "__canvas_createImageData",
      (width, height) => {
        return { id: -1, width, height };
      }
    );
    engine.global.set(
      "__canvas_getImageData",
      (x, y, width, height) => {
        const imageData = ctx.getImageData(x, y, width, height);
        return { id: -1, width, height, data: Array.from(imageData.data) };
      }
    );
    engine.global.set(
      "__canvas_imageDataGetPixel",
      (_id, x, y, data, width) => {
        if (!data || !width) return [0, 0, 0, 0];
        const i = (y * width + x) * 4;
        return [data[i], data[i + 1], data[i + 2], data[i + 3]];
      }
    );
    engine.global.set("__canvas_imageDataSetPixel", () => {
    });
    engine.global.set("__canvas_putImageData", () => {
    });
    engine.global.set("__canvas_cloneImageData", () => null);
    engine.global.set("__canvas_createPath", () => ({ id: -1 }));
    engine.global.set("__canvas_clonePath", () => ({ id: -1 }));
    engine.global.set("__canvas_disposePath", () => {
    });
    engine.global.set("__canvas_pathMoveTo", () => {
    });
    engine.global.set("__canvas_pathLineTo", () => {
    });
    engine.global.set("__canvas_pathClosePath", () => {
    });
    engine.global.set("__canvas_pathRect", () => {
    });
    engine.global.set("__canvas_pathRoundRect", () => {
    });
    engine.global.set("__canvas_pathArc", () => {
    });
    engine.global.set("__canvas_pathArcTo", () => {
    });
    engine.global.set("__canvas_pathEllipse", () => {
    });
    engine.global.set("__canvas_pathQuadraticCurveTo", () => {
    });
    engine.global.set("__canvas_pathBezierCurveTo", () => {
    });
    engine.global.set("__canvas_pathAddPath", () => {
    });
    engine.global.set("__canvas_fillPath", () => {
    });
    engine.global.set("__canvas_strokePath", () => {
    });
    engine.global.set("__canvas_clipPath", () => {
    });
    engine.global.set("__canvas_isPointInStoredPath", () => false);
    engine.global.set("__canvas_isPointInStoredStroke", () => false);
    engine.global.set(
      "__canvas_assets_loadSound",
      (name, filename) => {
        state.audioAssets.set(name, { name, filename, type: "sound" });
        return { _type: "sound", _name: name, _file: filename };
      }
    );
    engine.global.set(
      "__canvas_assets_loadMusic",
      (name, filename) => {
        state.audioAssets.set(name, { name, filename, type: "music" });
        return { _type: "music", _name: name, _file: filename };
      }
    );
    const extractAudioName = (nameOrHandle) => {
      if (typeof nameOrHandle === "string") {
        return nameOrHandle;
      }
      if (typeof nameOrHandle === "object" && nameOrHandle !== null && "_name" in nameOrHandle) {
        return nameOrHandle._name;
      }
      throw new Error("Invalid audio asset reference");
    };
    engine.global.set(
      "__audio_playSound",
      (nameOrHandle, volume) => {
        const name = extractAudioName(nameOrHandle);
        state.audioEngine.playSound(name, volume ?? 1);
      }
    );
    engine.global.set("__audio_getSoundDuration", (nameOrHandle) => {
      const name = extractAudioName(nameOrHandle);
      return state.audioEngine.getSoundDuration(name);
    });
    engine.global.set(
      "__audio_playMusic",
      (nameOrHandle, volume, loop) => {
        const name = extractAudioName(nameOrHandle);
        state.audioEngine.playMusic(name, {
          volume: volume ?? 1,
          loop: loop ?? false
        });
      }
    );
    engine.global.set("__audio_stopMusic", () => {
      state.audioEngine.stopMusic();
    });
    engine.global.set("__audio_pauseMusic", () => {
      state.audioEngine.pauseMusic();
    });
    engine.global.set("__audio_resumeMusic", () => {
      state.audioEngine.resumeMusic();
    });
    engine.global.set("__audio_setMusicVolume", (volume) => {
      state.audioEngine.setMusicVolume(volume);
    });
    engine.global.set("__audio_isMusicPlaying", () => {
      return state.audioEngine.isMusicPlaying();
    });
    engine.global.set("__audio_getMusicTime", () => {
      return state.audioEngine.getMusicTime();
    });
    engine.global.set("__audio_getMusicDuration", () => {
      return state.audioEngine.getMusicDuration();
    });
    engine.global.set("__audio_setMasterVolume", (volume) => {
      state.audioEngine.setMasterVolume(volume);
    });
    engine.global.set("__audio_getMasterVolume", () => {
      return state.audioEngine.getMasterVolume();
    });
    engine.global.set("__audio_mute", () => {
      state.audioEngine.mute();
    });
    engine.global.set("__audio_unmute", () => {
      state.audioEngine.unmute();
    });
    engine.global.set("__audio_isMuted", () => {
      return state.audioEngine.isMuted();
    });
  }

  // src/runtime/canvas-inline-entry.ts
  globalThis.CanvasStandalone = {
    setupCanvasBridge,
    createCanvasRuntimeState,
    setupInputListeners,
    canvasLuaCode
  };
  globalThis.setupCanvasBridge = setupCanvasBridge;
  globalThis.createCanvasRuntimeState = createCanvasRuntimeState;
  globalThis.setupInputListeners = setupInputListeners;
  globalThis.canvasLuaCode = canvasLuaCode;
})();
`
