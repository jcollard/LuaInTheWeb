/* eslint-disable max-lines */
/**
 * Auto-generated from canvas-inline-entry.ts
 * DO NOT EDIT THIS FILE DIRECTLY - edit the .ts source instead.
 *
 * Bundled canvas bridge for standalone HTML exports.
 * Run "npm run build:canvas" to regenerate this file.
 */
export const CANVAS_INLINE_JS = `"use strict";
var CanvasInline = (() => {
  // ../lua-runtime/src/canvasLuaCode/core.ts
  var canvasLuaCoreCode = \`
    local _canvas = {}

    -- Canvas lifecycle
    function _canvas.start()
      if __canvas_is_active() then
        error("Canvas is already running. Call canvas.stop() first.")
      end
      __canvas_start():await()
    end

    function _canvas.stop()
      __canvas_stop()
    end

    -- Store the user's callback and wrap with error handling
    local __user_tick_callback = nil
    local __user_tick_location = nil  -- Stores callback definition location
    local __current_font_size = 16  -- Track current font size for draw_label

    function _canvas.tick(callback)
      __user_tick_callback = callback
      -- Capture callback's definition location for better error messages
      local info = debug.getinfo(callback, "S")
      if info then
        local source = info.source or "?"
        local line = info.linedefined or 0
        -- Clean up source name (remove @ prefix if present)
        if source:sub(1, 1) == "@" then
          source = source:sub(2)
        end
        __user_tick_location = source .. ":" .. line
      end
      -- Create a wrapper that uses xpcall to capture stack trace on error
      __canvas_setOnDrawCallback(function()
        if __user_tick_callback then
          local success, err = xpcall(__user_tick_callback, function(e)
            -- Capture stack trace, skip internal frames
            return debug.traceback(e, 2)
          end)
          if not success then
            -- If error doesn't have Lua line info, add callback location
            local errStr = tostring(err)
            if __user_tick_location and not errStr:match(":%d+:") then
              err = __user_tick_location .. ": " .. errStr
            end
            error(err, 0)  -- Re-throw with location included
          end
        end
      end)
    end

    -- Canvas configuration
    function _canvas.set_size(width, height)
      __canvas_setSize(width, height)
    end

    function _canvas.get_width()
      return __canvas_getWidth()
    end

    function _canvas.get_height()
      return __canvas_getHeight()
    end

    -- Drawing state
    function _canvas.clear()
      __canvas_clear()
    end

    function _canvas.clear_rect(x, y, width, height)
      __canvas_clearRect(x, y, width, height)
    end

    -- Helper function to parse hex color string to RGBA
    local function parse_hex_color(hex)
      -- Remove the # prefix
      local color = hex:sub(2)
      local len = #color

      local r, g, b, a

      if len == 3 then
        -- Short form #RGB -> expand to #RRGGBB
        local r1 = tonumber(color:sub(1, 1), 16)
        local g1 = tonumber(color:sub(2, 2), 16)
        local b1 = tonumber(color:sub(3, 3), 16)
        if not r1 or not g1 or not b1 then
          error("Invalid hex color: " .. hex .. ". Contains non-hexadecimal characters")
        end
        r = r1 * 17
        g = g1 * 17
        b = b1 * 17
        a = 255
      elseif len == 6 then
        -- Full form #RRGGBB
        r = tonumber(color:sub(1, 2), 16)
        g = tonumber(color:sub(3, 4), 16)
        b = tonumber(color:sub(5, 6), 16)
        a = 255
        if not r or not g or not b then
          error("Invalid hex color: " .. hex .. ". Contains non-hexadecimal characters")
        end
      elseif len == 8 then
        -- Full form with alpha #RRGGBBAA
        r = tonumber(color:sub(1, 2), 16)
        g = tonumber(color:sub(3, 4), 16)
        b = tonumber(color:sub(5, 6), 16)
        a = tonumber(color:sub(7, 8), 16)
        if not r or not g or not b or not a then
          error("Invalid hex color: " .. hex .. ". Contains non-hexadecimal characters")
        end
      else
        error("Invalid hex color format: " .. hex .. ". Expected #RGB, #RRGGBB, or #RRGGBBAA")
      end

      return r, g, b, a
    end

    function _canvas.set_color(r, g, b, a)
      -- Check if first argument is a hex color string
      if type(r) == 'string' and r:sub(1, 1) == '#' then
        local hr, hg, hb, ha = parse_hex_color(r)
        __canvas_setColor(hr, hg, hb, ha)
      else
        __canvas_setColor(r, g, b, a)
      end
    end

    function _canvas.set_line_width(width)
      __canvas_setLineWidth(width)
    end

    -- Font styling
    function _canvas.set_font_size(size)
      __current_font_size = size
      __canvas_setFontSize(size)
    end

    function _canvas.set_font_family(family)
      __canvas_setFontFamily(family)
    end

    function _canvas.get_text_width(text)
      return __canvas_getTextWidth(text)
    end

    -- Shape drawing
    function _canvas.draw_rect(x, y, w, h)
      __canvas_rect(x, y, w, h)
    end

    function _canvas.fill_rect(x, y, w, h)
      __canvas_fillRect(x, y, w, h)
    end

    function _canvas.draw_circle(x, y, r)
      __canvas_circle(x, y, r)
    end

    function _canvas.fill_circle(x, y, r)
      __canvas_fillCircle(x, y, r)
    end

    function _canvas.draw_line(x1, y1, x2, y2)
      __canvas_line(x1, y1, x2, y2)
    end

    function _canvas.draw_text(x, y, text, options)
      local fontSize = nil
      local fontFamily = nil
      local maxWidth = nil
      if options then
        fontSize = options.font_size
        fontFamily = options.font_family
        maxWidth = options.max_width
      end
      __canvas_text(x, y, text, fontSize, fontFamily, maxWidth)
    end

    function _canvas.stroke_text(x, y, text, options)
      local fontSize = nil
      local fontFamily = nil
      local maxWidth = nil
      if options then
        fontSize = options.font_size
        fontFamily = options.font_family
        maxWidth = options.max_width
      end
      __canvas_strokeText(x, y, text, fontSize, fontFamily, maxWidth)
    end

    -- Image drawing
    -- Supports two forms:
    -- 1. draw_image(name, x, y, width?, height?) - draws at destination with optional scaling
    -- 2. draw_image(name, sx, sy, sw, sh, dx, dy, dw, dh) - crops source and draws to destination
    function _canvas.draw_image(name, x, y, width, height, sx, sy, sw, sh)
      __canvas_drawImage(name, x, y, width, height, sx, sy, sw, sh)
    end

    -- Asset management
    _canvas.assets = {}

    -- Register a directory path to scan for assets
    -- Must be called BEFORE canvas.start()
    function _canvas.assets.add_path(path)
      __canvas_assets_addPath(path)
    end

    -- Create a named reference to a discovered image file
    -- Returns an asset handle that can be used with draw_image
    -- Can be called before or after canvas.start()
    function _canvas.assets.load_image(name, filename)
      return __canvas_assets_loadImage(name, filename)
    end

    -- Create a named reference to a discovered font file
    -- Returns an asset handle that can be used with set_font_family
    -- Can be called before or after canvas.start()
    function _canvas.assets.load_font(name, filename)
      return __canvas_assets_loadFont(name, filename)
    end

    -- Create a named reference to a discovered sound file
    -- Returns an asset handle that can be used with play_sound
    -- Must be called before canvas.start()
    function _canvas.assets.load_sound(name, filename)
      return __canvas_assets_loadSound(name, filename)
    end

    -- Create a named reference to a discovered music file
    -- Returns an asset handle that can be used with play_music
    -- Must be called before canvas.start()
    function _canvas.assets.load_music(name, filename)
      return __canvas_assets_loadMusic(name, filename)
    end

    -- Get asset dimensions (accepts string name or asset handle)
    function _canvas.assets.get_width(name)
      return __canvas_assets_getWidth(name)
    end

    function _canvas.assets.get_height(name)
      return __canvas_assets_getHeight(name)
    end

    -- Transformation functions
    function _canvas.translate(dx, dy)
      __canvas_translate(dx, dy)
    end

    function _canvas.rotate(angle)
      __canvas_rotate(angle)
    end

    function _canvas.scale(sx, sy)
      __canvas_scale(sx, sy)
    end

    function _canvas.save()
      __canvas_save()
    end

    function _canvas.restore()
      __canvas_restore()
    end

    function _canvas.transform(a, b, c, d, e, f)
      __canvas_transform(a, b, c, d, e, f)
    end

    function _canvas.set_transform(a, b, c, d, e, f)
      __canvas_setTransform(a, b, c, d, e, f)
    end

    function _canvas.reset_transform()
      __canvas_resetTransform()
    end

    -- Timing
    function _canvas.get_delta()
      return __canvas_getDelta()
    end

    function _canvas.get_time()
      return __canvas_getTime()
    end

    -- Capture canvas as data URL
    function _canvas.capture(options)
      local format = nil
      local quality = nil
      if options then
        if options.format then
          -- Convert short format names to MIME types
          if options.format == "png" then
            format = "image/png"
          elseif options.format == "jpeg" or options.format == "jpg" then
            format = "image/jpeg"
          elseif options.format == "webp" then
            format = "image/webp"
          else
            format = options.format
          end
        end
        quality = options.quality
      end
      return __canvas_capture(format, quality)
    end

    -- Hot reload support
    -- Reloads a module by clearing it from cache and re-requiring it.
    -- Patches functions from new module into old table to preserve identity.
    ---@param module_name string The name of the module to reload
    ---@return any The reloaded module
    function __hot_reload(module_name)
      local entry = __loaded_modules[module_name]
      local old = entry and entry.module

      -- Clear from both caches to force re-loading
      __loaded_modules[module_name] = nil
      package.loaded[module_name] = nil

      -- Re-require the module (will re-execute the file)
      -- Wrap in pcall to catch errors and restore module on failure
      local ok, new = pcall(require, module_name)

      -- If reload failed, restore the old entry to keep it in the watch list
      if not ok then
        __loaded_modules[module_name] = entry
        package.loaded[module_name] = old
        -- Re-throw the error so canvas.reload() can report it
        error(new)
      end

      -- If both old and new are tables, patch functions from new into old
      -- This preserves table identity so existing references see updated functions
      if type(old) == 'table' and type(new) == 'table' then
        -- Update functions in the old table
        for key, value in pairs(new) do
          if type(value) == 'function' then
            old[key] = value
          end
        end

        -- Re-cache the OLD table (with updated functions) to preserve identity
        -- Note: __loaded_modules entry was already updated by require() with new content
        local newEntry = __loaded_modules[module_name]
        newEntry.module = old
        package.loaded[module_name] = old
        return old
      end

      -- If types don't match or not tables, return the new value
      return new
    end

    -- Built-in modules that should not be hot-reloaded
    local __builtin_modules = {
      canvas = true,
      shell = true,
      -- HC collision library - has internal state that breaks on reload
      hc = true,
      HC = true,
      ['HC.class'] = true,
      ['HC.polygon'] = true,
      ['HC.gjk'] = true,
      ['HC.shapes'] = true,
      ['HC.spatialhash'] = true,
      ['HC.vector-light'] = true,
    }

    -- Hot reload only modified user modules.
    -- Compares current file content with cached content to detect changes.
    -- Built-in modules (canvas, shell, HC library) are skipped.
    -- Large files (>50KB) are skipped with a warning.
    function _canvas.reload()
      local reloaded = {}
      local skipped = {}
      local large_files = {}
      local errors = {}

      for modname, entry in pairs(__loaded_modules) do
        -- Skip built-in modules
        if not __builtin_modules[modname] and not entry.builtin then
          -- Check if we have content tracking for this module
          if entry.content == nil then
            -- Large file - no content tracking
            if entry.filepath then
              table.insert(large_files, modname)
            end
          elseif entry.filepath then
            -- Read current file content using JS binding (synchronous)
            local currentContent = __canvas_read_file(entry.filepath)

            if currentContent then
              if currentContent ~= entry.content then
                -- Content changed - reload this module
                local reload_ok, reload_err = pcall(function()
                  __hot_reload(modname)
                end)

                if reload_ok then
                  table.insert(reloaded, modname)
                else
                  table.insert(errors, modname .. ": " .. tostring(reload_err))
                end
              else
                -- Content unchanged - skip
                table.insert(skipped, modname)
              end
            else
              -- Could not read file - try to reload anyway
              local reload_ok, reload_err = pcall(function()
                __hot_reload(modname)
              end)

              if reload_ok then
                table.insert(reloaded, modname)
              else
                table.insert(errors, modname .. ": " .. tostring(reload_err))
              end
            end
          end
        end
      end

      -- Report results
      if #reloaded > 0 then
        print("\\x1B[32mHot reloaded: " .. table.concat(reloaded, ", ") .. "\\x1B[0m")
        __js_flush()
      end

      if #skipped > 0 then
        print("Unchanged: " .. table.concat(skipped, ", "))
        __js_flush()
      end

      if #large_files > 0 then
        print("Warning: Skipped large files (>50KB): " .. table.concat(large_files, ", "))
        __js_flush()
      end

      if #errors > 0 then
        for _, err in ipairs(errors) do
          print("\\x1B[31mReload error: " .. err .. "\\x1B[0m")
        end
        __js_flush()
      end

      return #errors == 0
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/path.ts
  var canvasLuaPathCode = \`
    -- Path API
    function _canvas.begin_path()
      __canvas_beginPath()
    end

    function _canvas.close_path()
      __canvas_closePath()
    end

    function _canvas.move_to(x, y)
      __canvas_moveTo(x, y)
    end

    function _canvas.line_to(x, y)
      __canvas_lineTo(x, y)
    end

    function _canvas.fill()
      __canvas_fill()
    end

    function _canvas.stroke()
      __canvas_stroke()
    end

    function _canvas.arc(x, y, radius, startAngle, endAngle, counterclockwise)
      __canvas_arc(x, y, radius, startAngle, endAngle, counterclockwise or false)
    end

    function _canvas.arc_to(x1, y1, x2, y2, radius)
      __canvas_arcTo(x1, y1, x2, y2, radius)
    end

    function _canvas.quadratic_curve_to(cpx, cpy, x, y)
      __canvas_quadraticCurveTo(cpx, cpy, x, y)
    end

    function _canvas.bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y)
      __canvas_bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
    end

    function _canvas.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)
      __canvas_ellipse(x, y, radiusX, radiusY, rotation or 0, startAngle or 0, endAngle or (math.pi * 2), counterclockwise or false)
    end

    function _canvas.round_rect(x, y, width, height, radii)
      __canvas_roundRect(x, y, width, height, radii)
    end

    -- Add a rectangle to the current path (does not draw, use fill() or stroke() after)
    function _canvas.rect(x, y, width, height)
      __canvas_rectPath(x, y, width, height)
    end

    function _canvas.clip(fillRule)
      __canvas_clip(fillRule)
    end

    -- Hit Testing API
    function _canvas.is_point_in_path(x, y, fillRule)
      return __canvas_isPointInPath(x, y, fillRule or "nonzero")
    end

    function _canvas.is_point_in_stroke(x, y)
      return __canvas_isPointInStroke(x, y)
    end

    -- Pixel Manipulation API
    -- ImageData class for pixel-level access
    -- Uses JS-side storage for O(1) put_image_data performance
    local ImageData = {}
    ImageData.__index = ImageData

    function ImageData.new(jsInfo)
      local self = setmetatable({}, ImageData)
      self._jsId = jsInfo.id
      self.width = jsInfo.width
      self.height = jsInfo.height
      return self
    end

    function ImageData:get_pixel(x, y)
      local rgba = __canvas_imageDataGetPixel(self._jsId, x, y)
      return rgba[1], rgba[2], rgba[3], rgba[4]
    end

    function ImageData:set_pixel(x, y, r, g, b, a)
      __canvas_imageDataSetPixel(self._jsId, x, y, r, g, b, a or 255)
    end

    function _canvas.create_image_data(width, height)
      local info = __canvas_createImageData(width, height)
      return ImageData.new(info)
    end

    function _canvas.get_image_data(x, y, width, height)
      local info = __canvas_getImageData(x, y, width, height)
      if not info then return nil end
      return ImageData.new(info)
    end

    function _canvas.put_image_data(image_data, dx, dy, options)
      local dirtyX = nil
      local dirtyY = nil
      local dirtyWidth = nil
      local dirtyHeight = nil
      if options then
        dirtyX = options.dirty_x
        dirtyY = options.dirty_y
        dirtyWidth = options.dirty_width
        dirtyHeight = options.dirty_height
      end
      __canvas_putImageData(image_data._jsId, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)
    end

    function _canvas.clone_image_data(image_data)
      local info = __canvas_cloneImageData(image_data._jsId)
      if not info then return nil end
      return ImageData.new(info)
    end

    -- ==========================================================================
    -- Path2D API - Reusable path objects
    -- ==========================================================================

    -- Path2D class for reusable path objects
    local Path2D = {}
    Path2D.__index = Path2D

    function Path2D.new(jsInfo)
      local self = setmetatable({}, Path2D)
      self._jsId = jsInfo.id
      return self
    end

    -- Path building methods (all chainable, return self)
    function Path2D:move_to(x, y)
      __canvas_pathMoveTo(self._jsId, x, y)
      return self
    end

    function Path2D:line_to(x, y)
      __canvas_pathLineTo(self._jsId, x, y)
      return self
    end

    function Path2D:close_path()
      __canvas_pathClosePath(self._jsId)
      return self
    end

    function Path2D:rect(x, y, width, height)
      __canvas_pathRect(self._jsId, x, y, width, height)
      return self
    end

    function Path2D:round_rect(x, y, width, height, radii)
      __canvas_pathRoundRect(self._jsId, x, y, width, height, radii)
      return self
    end

    function Path2D:arc(x, y, radius, startAngle, endAngle, counterclockwise)
      __canvas_pathArc(self._jsId, x, y, radius, startAngle, endAngle, counterclockwise or false)
      return self
    end

    function Path2D:arc_to(x1, y1, x2, y2, radius)
      __canvas_pathArcTo(self._jsId, x1, y1, x2, y2, radius)
      return self
    end

    function Path2D:ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)
      __canvas_pathEllipse(self._jsId, x, y, radiusX, radiusY, rotation or 0, startAngle or 0, endAngle or (math.pi * 2), counterclockwise or false)
      return self
    end

    function Path2D:quadratic_curve_to(cpx, cpy, x, y)
      __canvas_pathQuadraticCurveTo(self._jsId, cpx, cpy, x, y)
      return self
    end

    function Path2D:bezier_curve_to(cp1x, cp1y, cp2x, cp2y, x, y)
      __canvas_pathBezierCurveTo(self._jsId, cp1x, cp1y, cp2x, cp2y, x, y)
      return self
    end

    function Path2D:add_path(other_path)
      __canvas_pathAddPath(self._jsId, other_path._jsId)
      return self
    end

    -- Dispose method to free memory
    function Path2D:dispose()
      __canvas_disposePath(self._jsId)
    end

    -- Create a new Path2D object
    -- Can be created empty, from SVG path string, or by cloning another path
    function _canvas.create_path(arg)
      if type(arg) == "string" then
        -- SVG path string
        local info = __canvas_createPath(arg)
        if not info then return nil end
        return Path2D.new(info)
      elseif type(arg) == "table" and arg._jsId then
        -- Clone from another Path2D
        local info = __canvas_clonePath(arg._jsId)
        if not info then return nil end
        return Path2D.new(info)
      else
        -- Empty path (arg is nil or ignored)
        local info = __canvas_createPath(nil)
        if not info then return nil end
        return Path2D.new(info)
      end
    end

    -- Extend fill/stroke/clip to accept optional Path2D argument
    local _original_fill = _canvas.fill
    function _canvas.fill(path_or_fill_rule, fill_rule)
      if type(path_or_fill_rule) == "table" and path_or_fill_rule._jsId then
        -- Path2D object passed
        __canvas_fillPath(path_or_fill_rule._jsId, fill_rule)
      else
        -- Original behavior (no path, just fill rule)
        _original_fill()
      end
    end

    local _original_stroke = _canvas.stroke
    function _canvas.stroke(path)
      if type(path) == "table" and path._jsId then
        -- Path2D object passed
        __canvas_strokePath(path._jsId)
      else
        -- Original behavior
        _original_stroke()
      end
    end

    local _original_clip = _canvas.clip
    function _canvas.clip(path_or_fill_rule, fill_rule)
      if type(path_or_fill_rule) == "table" and path_or_fill_rule._jsId then
        -- Path2D object passed
        __canvas_clipPath(path_or_fill_rule._jsId, fill_rule)
      else
        -- Original behavior (no path, just fill rule)
        _original_clip(path_or_fill_rule)
      end
    end

    -- Extend hit testing to accept optional Path2D argument
    local _original_is_point_in_path = _canvas.is_point_in_path
    function _canvas.is_point_in_path(path_or_x, x_or_y, y_or_fill_rule, fill_rule)
      if type(path_or_x) == "table" and path_or_x._jsId then
        -- Path2D object passed: is_point_in_path(path, x, y, fillRule?)
        return __canvas_isPointInStoredPath(path_or_x._jsId, x_or_y, y_or_fill_rule, fill_rule or "nonzero")
      else
        -- Original behavior: is_point_in_path(x, y, fillRule?)
        return _original_is_point_in_path(path_or_x, x_or_y, y_or_fill_rule)
      end
    end

    local _original_is_point_in_stroke = _canvas.is_point_in_stroke
    function _canvas.is_point_in_stroke(path_or_x, x_or_y, y)
      if type(path_or_x) == "table" and path_or_x._jsId then
        -- Path2D object passed: is_point_in_stroke(path, x, y)
        return __canvas_isPointInStoredStroke(path_or_x._jsId, x_or_y, y)
      else
        -- Original behavior: is_point_in_stroke(x, y)
        return _original_is_point_in_stroke(path_or_x, x_or_y)
      end
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/styling.ts
  var canvasLuaStylingCode = \`
    -- Line Style API
    function _canvas.set_line_cap(cap)
      __canvas_setLineCap(cap)
    end

    function _canvas.set_line_join(join)
      __canvas_setLineJoin(join)
    end

    function _canvas.set_miter_limit(limit)
      __canvas_setMiterLimit(limit)
    end

    function _canvas.set_line_dash(segments)
      -- Convert Lua table to JS array
      local js_segments = {}
      for i, v in ipairs(segments or {}) do
        js_segments[i] = v
      end
      __canvas_setLineDash(js_segments)
    end

    function _canvas.get_line_dash()
      local js_array = __canvas_getLineDash()
      local t = {}
      for i = 1, #js_array do
        t[i] = js_array[i]
      end
      return t
    end

    function _canvas.set_line_dash_offset(offset)
      __canvas_setLineDashOffset(offset)
    end

    -- Gradient API
    -- Metatable for gradient objects with add_color_stop method
    local GradientMT = {
      __index = {
        add_color_stop = function(self, offset, color)
          table.insert(self.stops, {offset = offset, color = color})
          return self  -- Enable method chaining
        end
      }
    }

    function _canvas.create_linear_gradient(x0, y0, x1, y1)
      return setmetatable({
        type = "linear",
        x0 = x0, y0 = y0, x1 = x1, y1 = y1,
        stops = {}
      }, GradientMT)
    end

    function _canvas.create_radial_gradient(x0, y0, r0, x1, y1, r1)
      return setmetatable({
        type = "radial",
        x0 = x0, y0 = y0, r0 = r0,
        x1 = x1, y1 = y1, r1 = r1,
        stops = {}
      }, GradientMT)
    end

    function _canvas.create_conic_gradient(startAngle, x, y)
      return setmetatable({
        type = "conic",
        startAngle = startAngle,
        x = x, y = y,
        stops = {}
      }, GradientMT)
    end

    function _canvas.create_pattern(imageName, repetition)
      repetition = repetition or "repeat"
      return {
        type = "pattern",
        imageName = imageName,
        repetition = repetition
      }
    end

    function _canvas.set_fill_style(style)
      __canvas_setFillStyle(style)
    end

    function _canvas.set_stroke_style(style)
      __canvas_setStrokeStyle(style)
    end

    -- Shadows
    function _canvas.set_shadow_color(color)
      __canvas_setShadowColor(color)
    end

    function _canvas.set_shadow_blur(blur)
      __canvas_setShadowBlur(blur)
    end

    function _canvas.set_shadow_offset_x(offset)
      __canvas_setShadowOffsetX(offset)
    end

    function _canvas.set_shadow_offset_y(offset)
      __canvas_setShadowOffsetY(offset)
    end

    function _canvas.set_shadow(color, blur, offsetX, offsetY)
      __canvas_setShadow(color, blur or 0, offsetX or 0, offsetY or 0)
    end

    function _canvas.clear_shadow()
      __canvas_clearShadow()
    end

    -- Compositing
    function _canvas.set_global_alpha(alpha)
      __canvas_setGlobalAlpha(alpha)
    end

    function _canvas.set_composite_operation(operation)
      __canvas_setCompositeOperation(operation)
    end

    -- Image smoothing (anti-aliasing for scaled images)
    -- Disable for crisp pixel art, enable for smooth scaled images
    function _canvas.set_image_smoothing(enabled)
      __canvas_setImageSmoothing(enabled)
    end

    -- CSS Filter
    function _canvas.set_filter(filter)
      __canvas_setFilter(filter)
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/text.ts
  var canvasLuaTextCode = \`
    -- Text Alignment
    function _canvas.set_text_align(align)
      __canvas_setTextAlign(align)
    end

    function _canvas.set_text_baseline(baseline)
      __canvas_setTextBaseline(baseline)
    end

    -- Draw text outline (stroke only, no fill)
    function _canvas.stroke_text(x, y, text, options)
      local fontSize = nil
      local fontFamily = nil
      local maxWidth = nil
      if options then
        fontSize = options.font_size
        fontFamily = options.font_family
        maxWidth = options.max_width
      end
      __canvas_strokeText(x, y, text, fontSize, fontFamily, maxWidth)
    end

    -- Get comprehensive text metrics
    -- Returns a table with:
    --   width: total text width
    --   actual_bounding_box_left: distance from alignment point to left edge
    --   actual_bounding_box_right: distance from alignment point to right edge
    --   actual_bounding_box_ascent: distance from baseline to top
    --   actual_bounding_box_descent: distance from baseline to bottom
    --   font_bounding_box_ascent: font ascent (highest glyph)
    --   font_bounding_box_descent: font descent (lowest glyph)
    function _canvas.get_text_metrics(text)
      local metrics = __canvas_getTextMetrics(text)
      return {
        width = metrics.width,
        actual_bounding_box_left = metrics.actualBoundingBoxLeft,
        actual_bounding_box_right = metrics.actualBoundingBoxRight,
        actual_bounding_box_ascent = metrics.actualBoundingBoxAscent,
        actual_bounding_box_descent = metrics.actualBoundingBoxDescent,
        font_bounding_box_ascent = metrics.fontBoundingBoxAscent,
        font_bounding_box_descent = metrics.fontBoundingBoxDescent,
      }
    end

    -- Text Direction (RTL/LTR support)
    function _canvas.set_direction(direction)
      __canvas_setDirection(direction)
    end

    -- Draw text within a bounded rectangle with alignment and overflow options
    function _canvas.draw_label(x, y, width, height, text, options)
      options = options or {}
      local align_h = options.align_h or "center"
      local align_v = options.align_v or "middle"
      local overflow = options.overflow or "visible"
      local padding = options.padding or {}
      local wrap = options.wrap or false
      local line_height = options.line_height or 1.2
      local char_count = options.char_count  -- nil means show all

      -- Normalize padding to {left, top, right, bottom}
      local pad_left = padding.left or 0
      local pad_top = padding.top or 0
      local pad_right = padding.right or 0
      local pad_bottom = padding.bottom or 0

      -- Calculate inner bounds after padding
      local inner_x = x + pad_left
      local inner_y = y + pad_top
      local inner_w = width - pad_left - pad_right
      local inner_h = height - pad_top - pad_bottom

      -- Calculate horizontal text position based on alignment
      local text_x
      if align_h == "left" then
        text_x = inner_x
      elseif align_h == "right" then
        text_x = inner_x + inner_w
      else -- center
        text_x = inner_x + inner_w / 2
      end

      -- Map align_h to Canvas textAlign values
      local canvas_align
      if align_h == "left" then
        canvas_align = "left"
      elseif align_h == "right" then
        canvas_align = "right"
      else
        canvas_align = "center"
      end

      -- Save state
      _canvas.save()

      -- Apply clipping if overflow is hidden or ellipsis
      if overflow == "hidden" or overflow == "ellipsis" then
        _canvas.begin_path()
        _canvas.move_to(x, y)
        _canvas.line_to(x + width, y)
        _canvas.line_to(x + width, y + height)
        _canvas.line_to(x, y + height)
        _canvas.close_path()
        _canvas.clip()
      end

      _canvas.set_text_align(canvas_align)

      -- Get font size for line height calculation
      local font_size = __current_font_size or 16
      local actual_line_height = font_size * line_height

      -- Word wrap logic (always wrap based on full text for stable layout)
      local lines = {}
      if wrap and inner_w > 0 then
        -- Split text into words
        local words = {}
        for word in text:gmatch("%S+") do
          table.insert(words, word)
        end

        local current_line = ""
        for i, word in ipairs(words) do
          local test_line = current_line == "" and word or (current_line .. " " .. word)
          local test_width = _canvas.get_text_width(test_line)

          if test_width > inner_w and current_line ~= "" then
            table.insert(lines, current_line)
            current_line = word
          else
            current_line = test_line
          end
        end
        if current_line ~= "" then
          table.insert(lines, current_line)
        end
      else
        -- No wrapping - single line
        local display_text = text

        if overflow == "ellipsis" and inner_w > 0 then
          local text_width = _canvas.get_text_width(text)
          if text_width > inner_w then
            local ellipsis = "..."
            local ellipsis_width = _canvas.get_text_width(ellipsis)
            local available = inner_w - ellipsis_width

            if available > 0 then
              local truncated = ""
              for i = 1, #text do
                local test = text:sub(1, i)
                if _canvas.get_text_width(test) > available then
                  break
                end
                truncated = test
              end
              display_text = truncated .. ellipsis
            else
              display_text = ellipsis
            end
          end
        end

        table.insert(lines, display_text)
      end

      -- Calculate total text block height
      local total_height = #lines * actual_line_height

      -- Calculate starting Y position based on vertical alignment
      local start_y
      if align_v == "top" then
        start_y = inner_y + actual_line_height / 2
      elseif align_v == "bottom" then
        start_y = inner_y + inner_h - total_height + actual_line_height / 2
      else -- middle
        start_y = inner_y + (inner_h - total_height) / 2 + actual_line_height / 2
      end

      -- Draw each line, applying char_count limit if specified
      _canvas.set_text_baseline("middle")
      local chars_remaining = char_count  -- nil means unlimited
      for i, line in ipairs(lines) do
        local line_y = start_y + (i - 1) * actual_line_height

        if chars_remaining == nil then
          -- No limit, draw full line
          _canvas.draw_text(text_x, line_y, line)
        elseif chars_remaining > 0 then
          -- Apply character limit
          local line_to_draw = line:sub(1, chars_remaining)
          _canvas.draw_text(text_x, line_y, line_to_draw)
          chars_remaining = chars_remaining - #line - 1  -- -1 for space between lines
        end
        -- If chars_remaining <= 0, skip drawing this line
      end

      -- Restore state
      _canvas.restore()
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/input.ts
  var canvasLuaInputCode = \`
    -- Helper to normalize key names
    local function normalize_key(key)
      if type(key) ~= 'string' then return key end
      -- Single letter keys
      if #key == 1 and key:match('%a') then
        return 'Key' .. key:upper()
      end
      -- Arrow keys
      local arrows = { up = 'ArrowUp', down = 'ArrowDown', left = 'ArrowLeft', right = 'ArrowRight' }
      if arrows[key:lower()] then
        return arrows[key:lower()]
      end
      -- Space key
      if key:lower() == 'space' or key == ' ' then
        return 'Space'
      end
      -- Common keys
      local common = {
        enter = 'Enter', escape = 'Escape', esc = 'Escape',
        tab = 'Tab', shift = 'ShiftLeft', ctrl = 'ControlLeft',
        alt = 'AltLeft', backspace = 'Backspace'
      }
      if common[key:lower()] then
        return common[key:lower()]
      end
      return key
    end

    -- Keyboard input
    function _canvas.is_key_down(key)
      return __canvas_isKeyDown(normalize_key(key))
    end

    function _canvas.is_key_pressed(key)
      return __canvas_isKeyPressed(normalize_key(key))
    end

    -- Helper to convert JS array proxy to plain Lua table
    -- This ensures proper Lua errors with line numbers instead of JS TypeErrors
    local function to_lua_array(js_array)
      local t = {}
      for i = 1, #js_array do
        t[i] = js_array[i]
      end
      return t
    end

    function _canvas.get_keys_down()
      return to_lua_array(__canvas_getKeysDown())
    end

    function _canvas.get_keys_pressed()
      return to_lua_array(__canvas_getKeysPressed())
    end

    -- Mouse input
    function _canvas.get_mouse_x()
      return __canvas_getMouseX()
    end

    function _canvas.get_mouse_y()
      return __canvas_getMouseY()
    end

    function _canvas.is_mouse_down(button)
      return __canvas_isMouseDown(button)
    end

    function _canvas.is_mouse_pressed(button)
      return __canvas_isMousePressed(button)
    end

    -- Gamepad input
    -- Note: Lua uses 1-based indexing, so we subtract 1 when calling JS functions

    function _canvas.get_gamepad_count()
      return __canvas_getGamepadCount()
    end

    function _canvas.is_gamepad_connected(index)
      return __canvas_isGamepadConnected(index - 1)
    end

    function _canvas.get_gamepad_button(gamepad_index, button)
      -- Both indices are 1-based in Lua, convert to 0-based for JS
      return __canvas_getGamepadButton(gamepad_index - 1, button - 1)
    end

    function _canvas.is_gamepad_button_pressed(gamepad_index, button)
      return __canvas_isGamepadButtonPressed(gamepad_index - 1, button - 1)
    end

    function _canvas.get_gamepad_axis(gamepad_index, axis)
      return __canvas_getGamepadAxis(gamepad_index - 1, axis - 1)
    end

    -- Gamepad button constants (1-based for Lua)
    -- Following W3C Standard Gamepad mapping with position-based names (SDL3/Unity convention)
    _canvas.buttons = {
      -- Position-based (PRIMARY - recommended for cross-platform code)
      SOUTH = 1, EAST = 2, WEST = 3, NORTH = 4,

      -- Xbox aliases
      A = 1, B = 2, X = 3, Y = 4,
      LB = 5, RB = 6, LT = 7, RT = 8,
      BACK = 9, START = 10,

      -- PlayStation aliases
      CROSS = 1, CIRCLE = 2, SQUARE = 3, TRIANGLE = 4,
      L1 = 5, R1 = 6, L2 = 7, R2 = 8,
      SELECT = 9, OPTIONS = 10, SHARE = 9,
      L3 = 11, R3 = 12,

      -- Generic names
      LEFT_BUMPER = 5, RIGHT_BUMPER = 6,
      LEFT_TRIGGER = 7, RIGHT_TRIGGER = 8,
      LEFT_STICK = 11, RIGHT_STICK = 12, LS = 11, RS = 12,
      DPAD_UP = 13, DPAD_DOWN = 14, DPAD_LEFT = 15, DPAD_RIGHT = 16,
      HOME = 17, GUIDE = 17,
    }

    -- Gamepad axis constants (1-based for Lua)
    _canvas.axes = {
      LEFT_STICK_X = 1,
      LEFT_STICK_Y = 2,
      RIGHT_STICK_X = 3,
      RIGHT_STICK_Y = 4,
    }

    -- Key constants for discoverability
    _canvas.keys = {
      -- Letters
      A = 'KeyA', B = 'KeyB', C = 'KeyC', D = 'KeyD', E = 'KeyE',
      F = 'KeyF', G = 'KeyG', H = 'KeyH', I = 'KeyI', J = 'KeyJ',
      K = 'KeyK', L = 'KeyL', M = 'KeyM', N = 'KeyN', O = 'KeyO',
      P = 'KeyP', Q = 'KeyQ', R = 'KeyR', S = 'KeyS', T = 'KeyT',
      U = 'KeyU', V = 'KeyV', W = 'KeyW', X = 'KeyX', Y = 'KeyY', Z = 'KeyZ',

      -- Number row
      ['0'] = 'Digit0', ['1'] = 'Digit1', ['2'] = 'Digit2', ['3'] = 'Digit3',
      ['4'] = 'Digit4', ['5'] = 'Digit5', ['6'] = 'Digit6', ['7'] = 'Digit7',
      ['8'] = 'Digit8', ['9'] = 'Digit9',
      DIGIT_0 = 'Digit0', DIGIT_1 = 'Digit1', DIGIT_2 = 'Digit2', DIGIT_3 = 'Digit3',
      DIGIT_4 = 'Digit4', DIGIT_5 = 'Digit5', DIGIT_6 = 'Digit6', DIGIT_7 = 'Digit7',
      DIGIT_8 = 'Digit8', DIGIT_9 = 'Digit9',

      -- Arrow keys
      UP = 'ArrowUp', DOWN = 'ArrowDown', LEFT = 'ArrowLeft', RIGHT = 'ArrowRight',
      ARROW_UP = 'ArrowUp', ARROW_DOWN = 'ArrowDown', ARROW_LEFT = 'ArrowLeft', ARROW_RIGHT = 'ArrowRight',

      -- Function keys
      F1 = 'F1', F2 = 'F2', F3 = 'F3', F4 = 'F4', F5 = 'F5', F6 = 'F6',
      F7 = 'F7', F8 = 'F8', F9 = 'F9', F10 = 'F10', F11 = 'F11', F12 = 'F12',

      -- Modifier keys
      SHIFT = 'ShiftLeft', SHIFT_LEFT = 'ShiftLeft', SHIFT_RIGHT = 'ShiftRight',
      CTRL = 'ControlLeft', CTRL_LEFT = 'ControlLeft', CTRL_RIGHT = 'ControlRight',
      CONTROL = 'ControlLeft', CONTROL_LEFT = 'ControlLeft', CONTROL_RIGHT = 'ControlRight',
      ALT = 'AltLeft', ALT_LEFT = 'AltLeft', ALT_RIGHT = 'AltRight',
      META = 'MetaLeft', META_LEFT = 'MetaLeft', META_RIGHT = 'MetaRight',
      CAPS_LOCK = 'CapsLock',

      -- Special keys
      SPACE = 'Space', ENTER = 'Enter', ESCAPE = 'Escape', TAB = 'Tab',
      BACKSPACE = 'Backspace', DELETE = 'Delete', INSERT = 'Insert',
      HOME = 'Home', END = 'End', PAGE_UP = 'PageUp', PAGE_DOWN = 'PageDown',
      PRINT_SCREEN = 'PrintScreen', SCROLL_LOCK = 'ScrollLock', PAUSE = 'Pause',
      NUM_LOCK = 'NumLock',

      -- Numpad keys
      NUMPAD_0 = 'Numpad0', NUMPAD_1 = 'Numpad1', NUMPAD_2 = 'Numpad2', NUMPAD_3 = 'Numpad3',
      NUMPAD_4 = 'Numpad4', NUMPAD_5 = 'Numpad5', NUMPAD_6 = 'Numpad6', NUMPAD_7 = 'Numpad7',
      NUMPAD_8 = 'Numpad8', NUMPAD_9 = 'Numpad9',
      NUMPAD_ADD = 'NumpadAdd', NUMPAD_SUBTRACT = 'NumpadSubtract',
      NUMPAD_MULTIPLY = 'NumpadMultiply', NUMPAD_DIVIDE = 'NumpadDivide',
      NUMPAD_DECIMAL = 'NumpadDecimal', NUMPAD_ENTER = 'NumpadEnter',

      -- Punctuation and symbols
      MINUS = 'Minus', EQUAL = 'Equal', BRACKET_LEFT = 'BracketLeft', BRACKET_RIGHT = 'BracketRight',
      BACKSLASH = 'Backslash', SEMICOLON = 'Semicolon', QUOTE = 'Quote',
      BACKQUOTE = 'Backquote', COMMA = 'Comma', PERIOD = 'Period', SLASH = 'Slash',

      -- Context menu key
      CONTEXT_MENU = 'ContextMenu',
    }

    -- Register canvas as a module so require('canvas') works
    -- Note: canvas is NOT a global - it must be accessed via require('canvas')
    package.preload['canvas'] = function()
      return _canvas
    end
\`;

  // ../lua-runtime/src/canvasLuaCode/audio.ts
  var canvasLuaAudioCode = \`
    -- ========================================================================
    -- Audio API
    -- ========================================================================

    -- Sound effect playback (can overlap)
    function _canvas.play_sound(name, volume)
      __audio_playSound(name, volume)
    end

    -- Get the duration of a sound in seconds
    function _canvas.get_sound_duration(name)
      return __audio_getSoundDuration(name)
    end

    -- Music playback (one track at a time)
    function _canvas.play_music(name, options)
      local volume = 1
      local loop = false
      if options then
        if options.volume then volume = options.volume end
        if options.loop then loop = options.loop end
      end
      __audio_playMusic(name, volume, loop)
    end

    function _canvas.stop_music()
      __audio_stopMusic()
    end

    function _canvas.pause_music()
      __audio_pauseMusic()
    end

    function _canvas.resume_music()
      __audio_resumeMusic()
    end

    function _canvas.set_music_volume(volume)
      __audio_setMusicVolume(volume)
    end

    function _canvas.is_music_playing()
      return __audio_isMusicPlaying()
    end

    function _canvas.get_music_time()
      return __audio_getMusicTime()
    end

    function _canvas.get_music_duration()
      return __audio_getMusicDuration()
    end

    -- Global audio control
    function _canvas.set_master_volume(volume)
      __audio_setMasterVolume(volume)
    end

    function _canvas.get_master_volume()
      return __audio_getMasterVolume()
    end

    function _canvas.mute()
      __audio_mute()
    end

    function _canvas.unmute()
      __audio_unmute()
    end

    function _canvas.is_muted()
      return __audio_isMuted()
    end

    -- ========================================================================
    -- Audio Channel API
    -- ========================================================================

    function _canvas.channel_create(name, options)
      local parent = nil
      if options and options.parent then
        parent = options.parent
      end
      __audio_channelCreate(name, parent)
    end

    function _canvas.channel_get_parent(name)
      return __audio_channelGetParent(name)
    end

    function _canvas.channel_set_parent(name, parent)
      __audio_channelSetParent(name, parent)
    end

    function _canvas.channel_get_effective_volume(name)
      return __audio_channelGetEffectiveVolume(name)
    end

    function _canvas.channel_destroy(name)
      __audio_channelDestroy(name)
    end

    function _canvas.channel_play(channel, audio, options)
      local volume = 1
      local loop = false
      local start_time = 0
      if options then
        if options.volume then volume = options.volume end
        if options.loop then loop = options.loop end
        if options.start_time then start_time = options.start_time end
      end
      __audio_channelPlay(channel, audio, volume, loop, start_time)
    end

    function _canvas.channel_stop(channel)
      __audio_channelStop(channel)
    end

    function _canvas.channel_pause(channel)
      __audio_channelPause(channel)
    end

    function _canvas.channel_resume(channel)
      __audio_channelResume(channel)
    end

    function _canvas.channel_set_volume(channel, volume)
      __audio_channelSetVolume(channel, volume)
    end

    function _canvas.channel_get_volume(channel)
      return __audio_channelGetVolume(channel)
    end

    function _canvas.channel_fade_to(channel, targetVolume, duration)
      __audio_channelFadeTo(channel, targetVolume, duration)
    end

    function _canvas.channel_is_playing(channel)
      return __audio_channelIsPlaying(channel)
    end

    function _canvas.channel_is_fading(channel)
      return __audio_channelIsFading(channel)
    end

    function _canvas.channel_get_time(channel)
      return __audio_channelGetTime(channel)
    end

    function _canvas.channel_get_duration(channel)
      return __audio_channelGetDuration(channel)
    end

    function _canvas.channel_get_audio(channel)
      return __audio_channelGetAudio(channel)
    end
\`;

  // ../lua-runtime/src/lua/hc.generated.ts
  var LUA_HC_CODE = \`---@meta hc
--- hc.lua - HC Collision Detection Library
--- Load with: local HC = require('hc')
---
--- A collision detection library for 2D games.
--- Source: https://github.com/vrld/HC
---
--- Provides collision detection between arbitrary shapes:
--- - Circles, rectangles, and polygons (convex and concave)
--- - Uses spatial hashing for efficient broad-phase collision detection
--- - Uses GJK algorithm for precise narrow-phase collision detection
---
--- @module hc

--[[
MIT License

Copyright (c) 2010-2012 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

-- Lua 5.1/5.4 compatibility: unpack moved to table.unpack in 5.2+
-- Make unpack globally available for all submodules
if not unpack then
  unpack = table.unpack
end

--------------------------------------------------------------------------------
-- HC.vector-light: Lightweight 2D vector operations
--------------------------------------------------------------------------------
package.preload['HC.vector-light'] = function()
  local sqrt, cos, sin = math.sqrt, math.cos, math.sin

  local function str(x,y)
    return "("..tonumber(x)..","..tonumber(y)..")"
  end

  local function mul(s, x,y)
    return s*x, s*y
  end

  local function div(s, x,y)
    return x/s, y/s
  end

  local function add(x1,y1, x2,y2)
    return x1+x2, y1+y2
  end

  local function sub(x1,y1, x2,y2)
    return x1-x2, y1-y2
  end

  local function permul(x1,y1, x2,y2)
    return x1*x2, y1*y2
  end

  local function dot(x1,y1, x2,y2)
    return x1*x2 + y1*y2
  end

  local function det(x1,y1, x2,y2)
    return x1*y2 - y1*x2
  end

  local function eq(x1,y1, x2,y2)
    return x1 == x2 and y1 == y2
  end

  local function lt(x1,y1, x2,y2)
    return x1 < x2 or (x1 == x2 and y1 < y2)
  end

  local function le(x1,y1, x2,y2)
    return x1 <= x2 and y1 <= y2
  end

  local function len2(x,y)
    return x*x + y*y
  end

  local function len(x,y)
    return sqrt(x*x + y*y)
  end

  local function dist(x1,y1, x2,y2)
    return len(x1-x2, y1-y2)
  end

  local function normalize(x,y)
    local l = len(x,y)
    return x/l, y/l
  end

  local function rotate(phi, x,y)
    local c, s = cos(phi), sin(phi)
    return c*x - s*y, s*x + c*y
  end

  local function perpendicular(x,y)
    return -y, x
  end

  local function project(x,y, u,v)
    local s = (x*u + y*v) / (u*u + v*v)
    return s*u, s*v
  end

  local function mirror(x,y, u,v)
    local s = 2 * (x*u + y*v) / (u*u + v*v)
    return s*u - x, s*v - y
  end

  return {
    str = str,
    mul    = mul,
    div    = div,
    add    = add,
    sub    = sub,
    permul = permul,
    dot    = dot,
    det    = det,
    cross  = det,
    eq = eq,
    lt = lt,
    le = le,
    len2          = len2,
    len           = len,
    dist          = dist,
    normalize     = normalize,
    rotate        = rotate,
    perpendicular = perpendicular,
    project       = project,
    mirror        = mirror,
  }
end

--------------------------------------------------------------------------------
-- HC.class: Simple class system with inheritance
--------------------------------------------------------------------------------
package.preload['HC.class'] = function()
  local function __NULL__() end

  local function inherit(class, interface, ...)
    if not interface then return end
    assert(type(interface) == "table", "Can only inherit from other classes.")

    for name, func in pairs(interface) do
      if not class[name] then
        class[name] = func
      end
    end
    for super in pairs(interface.__is_a or {}) do
      class.__is_a[super] = true
    end

    return inherit(class, ...)
  end

  local function new(args)
    local super = {}
    local name = '<unnamed class>'
    local constructor = args or __NULL__
    if type(args) == "table" then
      super = (args.inherits or {}).__is_a and {args.inherits} or args.inherits or {}
      name = args.name or name
      constructor = args[1] or __NULL__
    end
    assert(type(constructor) == "function", 'constructor has to be nil or a function')

    local class = {}
    class.__index = class
    class.__tostring = function() return ("<instance of %s>"):format(tostring(class)) end
    class.construct = constructor or __NULL__
    class.inherit = inherit
    class.__is_a = {[class] = true}
    class.is_a = function(self, other) return not not self.__is_a[other] end

    inherit(class, unpack(super))

    local meta = {
      __call = function(self, ...)
        local obj = {}
        setmetatable(obj, self)
        self.construct(obj, ...)
        return obj
      end,
      __tostring = function() return name end
    }
    return setmetatable(class, meta)
  end

  -- Set up class commons interface
  if common_class ~= false and not common then
    common = {}
    function common.class(name, prototype, parent)
      local init = prototype.init or (parent or {}).init
      return new{name = name, inherits = {prototype, parent}, init}
    end
    function common.instance(class, ...)
      return class(...)
    end
  end

  return setmetatable({new = new, inherit = inherit},
    {__call = function(_,...) return new(...) end})
end

--------------------------------------------------------------------------------
-- HC.gjk: Gilbert-Johnson-Keerthi collision detection algorithm
--------------------------------------------------------------------------------
package.preload['HC.gjk'] = function()
  local _PACKAGE = 'HC'
  local vector  = require(_PACKAGE .. '.vector-light')
  local huge, abs = math.huge, math.abs

  local simplex, edge = {}, {}

  local function support(shape_a, shape_b, dx, dy)
    local x,y = shape_a:support(dx,dy)
    return vector.sub(x,y, shape_b:support(-dx, -dy))
  end

  local function closest_edge(n)
    edge.dist = huge

    local i = n-1
    for k = 1,n-1,2 do
      local ax,ay = simplex[i], simplex[i+1]
      local bx,by = simplex[k], simplex[k+1]
      i = k

      local ex,ey = vector.perpendicular(bx-ax, by-ay)
      local nx,ny = vector.normalize(ex,ey)
      local d = vector.dot(ax,ay, nx,ny)

      if d < edge.dist then
        edge.dist = d
        edge.nx, edge.ny = nx, ny
        edge.i = k
      end
    end
  end

  local function EPA(shape_a, shape_b)
    local cx,cy, bx,by, ax,ay = unpack(simplex, 1, 6)
    if vector.dot(ax-bx,ay-by, cx-bx,cy-by) < 0 then
      simplex[1],simplex[2] = ax,ay
      simplex[5],simplex[6] = cx,cy
    end

    local is_either_circle = shape_a._center or shape_b._center
    local last_diff_dist, n = huge, 6
    while true do
      closest_edge(n)
      local px,py = support(shape_a, shape_b, edge.nx, edge.ny)
      local d = vector.dot(px,py, edge.nx, edge.ny)

      local diff_dist = d - edge.dist
      if diff_dist < 1e-6 or (is_either_circle and abs(last_diff_dist - diff_dist) < 1e-10) then
        return -d*edge.nx, -d*edge.ny
      end
      last_diff_dist = diff_dist

      for i = n, edge.i, -1 do
        simplex[i+2] = simplex[i]
      end
      simplex[edge.i+0] = px
      simplex[edge.i+1] = py
      n = n + 2
    end
  end

  local function do_line()
    local bx,by, ax,ay = unpack(simplex, 1, 4)
    local abx,aby = bx-ax, by-ay
    local dx,dy = vector.perpendicular(abx,aby)

    if vector.dot(dx,dy, -ax,-ay) < 0 then
      dx,dy = -dx,-dy
    end
    return dx,dy
  end

  local function do_triangle()
    local cx,cy, bx,by, ax,ay = unpack(simplex, 1, 6)
    local aox,aoy = -ax,-ay
    local abx,aby = bx-ax, by-ay
    local acx,acy = cx-ax, cy-ay

    local dx,dy = vector.perpendicular(abx,aby)
    if vector.dot(dx,dy, acx,acy) > 0 then
      dx,dy = -dx,-dy
    end
    if vector.dot(dx,dy, aox,aoy) > 0 then
      simplex[1], simplex[2] = bx,by
      simplex[3], simplex[4] = ax,ay
      return 4, dx,dy
    end

    dx,dy = vector.perpendicular(acx,acy)
    if vector.dot(dx,dy, abx,aby) > 0 then
      dx,dy = -dx,-dy
    end
    if vector.dot(dx,dy, aox, aoy) > 0 then
      simplex[3], simplex[4] = ax,ay
      return 4, dx,dy
    end

    return 6
  end

  local function GJK(shape_a, shape_b)
    local ax,ay = support(shape_a, shape_b, 1,0)
    if ax == 0 and ay == 0 then
      return false
    end

    simplex[1], simplex[2] = ax, ay
    local dx,dy = -ax,-ay

    ax,ay = support(shape_a, shape_b, dx,dy)
    if vector.dot(ax,ay, dx,dy) <= 0 then
      return false
    end

    simplex[3], simplex[4] = ax,ay
    dx, dy = do_line()

    local n

    while true do
      ax,ay = support(shape_a, shape_b, dx,dy)

      if vector.dot(ax,ay, dx,dy) <= 0 then
        return false
      end

      simplex[5], simplex[6] = ax,ay
      n, dx, dy = do_triangle()

      if n == 6 then
        return true, EPA(shape_a, shape_b)
      end
    end
  end

  return GJK
end

--------------------------------------------------------------------------------
-- HC.polygon: Polygon geometry and operations
--------------------------------------------------------------------------------
package.preload['HC.polygon'] = function()
  local _PACKAGE = 'HC'
  local common_local = common
  if not (type(common) == 'table' and common.class and common.instance) then
    assert(common_class ~= false, 'No class commons specification available.')
    require(_PACKAGE .. '.class')
    common_local, common = common, common_local
  end
  local vector = require(_PACKAGE .. '.vector-light')

  local function toVertexList(vertices, x,y, ...)
    if not (x and y) then return vertices end
    vertices[#vertices + 1] = {x = x, y = y}
    return toVertexList(vertices, ...)
  end

  local function areCollinear(p, q, r, eps)
    return math.abs(vector.det(q.x-p.x, q.y-p.y,  r.x-p.x,r.y-p.y)) <= (eps or 1e-32)
  end

  local function removeCollinear(vertices)
    local ret = {}
    local i,k = #vertices - 1, #vertices
    for l=1,#vertices do
      if not areCollinear(vertices[i], vertices[k], vertices[l]) then
        ret[#ret+1] = vertices[k]
      end
      i,k = k,l
    end
    return ret
  end

  local function getIndexOfleftmost(vertices)
    local idx = 1
    for i = 2,#vertices do
      if vertices[i].x < vertices[idx].x then
        idx = i
      end
    end
    return idx
  end

  local function ccw(p, q, r)
    return vector.det(q.x-p.x, q.y-p.y,  r.x-p.x, r.y-p.y) >= 0
  end

  local function onSameSide(a,b, c,d)
    local px, py = d.x-c.x, d.y-c.y
    local l = vector.det(px,py,  a.x-c.x, a.y-c.y)
    local m = vector.det(px,py,  b.x-c.x, b.y-c.y)
    return l*m >= 0
  end

  local function pointInTriangle(p, a,b,c)
    return onSameSide(p,a, b,c) and onSameSide(p,b, a,c) and onSameSide(p,c, a,b)
  end

  local function anyPointInTriangle(vertices, p,q,r)
    for v in pairs(vertices) do
      if v ~= p and v ~= q and v ~= r and pointInTriangle(v, p,q,r) then
        return true
      end
    end
    return false
  end

  local function isEar(p,q,r, vertices)
    return ccw(p,q,r) and not anyPointInTriangle(vertices, p,q,r)
  end

  local function segmentsInterset(a,b, p,q)
    return not (onSameSide(a,b, p,q) or onSameSide(p,q, a,b))
  end

  local function getSharedEdge(p,q)
    local pindex = setmetatable({}, {__index = function(t,k)
      local s = {}
      t[k] = s
      return s
    end})

    for i = 1,#p do
      pindex[p[i].x][p[i].y] = i
    end

    local i,k = #q,1
    for k = 1,#q do
      local v,w = q[i], q[k]
      if pindex[v.x][v.y] and pindex[w.x][w.y] then
        return pindex[w.x][w.y], k
      end
      i = k
    end
  end

  local Polygon = {}
  function Polygon:init(...)
    local vertices = removeCollinear( toVertexList({}, ...) )
    assert(#vertices >= 3, "Need at least 3 non collinear points to build polygon (got "..#vertices..")")

    local r = getIndexOfleftmost(vertices)
    local q = r > 1 and r - 1 or #vertices
    local s = r < #vertices and r + 1 or 1
    if not ccw(vertices[q], vertices[r], vertices[s]) then
      local tmp = {}
      for i=#vertices,1,-1 do
        tmp[#tmp + 1] = vertices[i]
      end
      vertices = tmp
    end

    local q,p = vertices[#vertices]
    for i = 1,#vertices-2 do
      p, q = q, vertices[i]
      for k = i+1,#vertices-1 do
        local a,b = vertices[k], vertices[k+1]
        assert(not segmentsInterset(p,q, a,b), 'Polygon may not intersect itself')
      end
    end

    self.vertices = vertices
    setmetatable(self.vertices, {__newindex = function() error("Thou shall not change a polygon's vertices!") end})

    local p,q = vertices[#vertices], vertices[1]
    local det = vector.det(p.x,p.y, q.x,q.y)
    self.area = det
    for i = 2,#vertices do
      p,q = q,vertices[i]
      self.area = self.area + vector.det(p.x,p.y, q.x,q.y)
    end
    self.area = self.area / 2

    p,q = vertices[#vertices], vertices[1]
    self.centroid = {x = (p.x+q.x)*det, y = (p.y+q.y)*det}
    for i = 2,#vertices do
      p,q = q,vertices[i]
      det = vector.det(p.x,p.y, q.x,q.y)
      self.centroid.x = self.centroid.x + (p.x+q.x) * det
      self.centroid.y = self.centroid.y + (p.y+q.y) * det
    end
    self.centroid.x = self.centroid.x / (6 * self.area)
    self.centroid.y = self.centroid.y / (6 * self.area)

    self._radius = 0
    for i = 1,#vertices do
      self._radius = math.max(self._radius,
        vector.dist(vertices[i].x,vertices[i].y, self.centroid.x,self.centroid.y))
    end
  end
  local newPolygon

  function Polygon:unpack()
    local v = {}
    for i = 1,#self.vertices do
      v[2*i-1] = self.vertices[i].x
      v[2*i]   = self.vertices[i].y
    end
    return unpack(v)
  end

  function Polygon:clone()
    return Polygon( self:unpack() )
  end

  function Polygon:bbox()
    local ulx,uly = self.vertices[1].x, self.vertices[1].y
    local lrx,lry = ulx,uly
    for i=2,#self.vertices do
      local p = self.vertices[i]
      if ulx > p.x then ulx = p.x end
      if uly > p.y then uly = p.y end
      if lrx < p.x then lrx = p.x end
      if lry < p.y then lry = p.y end
    end
    return ulx,uly, lrx,lry
  end

  function Polygon:isConvex()
    local function isConvex()
      local v = self.vertices
      if #v == 3 then return true end

      if not ccw(v[#v], v[1], v[2]) then
        return false
      end
      for i = 2,#v-1 do
        if not ccw(v[i-1], v[i], v[i+1]) then
          return false
        end
      end
      if not ccw(v[#v-1], v[#v], v[1]) then
        return false
      end
      return true
    end

    local status = isConvex()
    self.isConvex = function() return status end
    return status
  end

  function Polygon:move(dx, dy)
    if not dy then
      dx, dy = dx:unpack()
    end
    for i,v in ipairs(self.vertices) do
      v.x = v.x + dx
      v.y = v.y + dy
    end
    self.centroid.x = self.centroid.x + dx
    self.centroid.y = self.centroid.y + dy
  end

  function Polygon:rotate(angle, cx, cy)
    if not (cx and cy) then
      cx,cy = self.centroid.x, self.centroid.y
    end
    for i,v in ipairs(self.vertices) do
      v.x,v.y = vector.add(cx,cy, vector.rotate(angle, v.x-cx, v.y-cy))
    end
    local v = self.centroid
    v.x,v.y = vector.add(cx,cy, vector.rotate(angle, v.x-cx, v.y-cy))
  end

  function Polygon:scale(s, cx,cy)
    if not (cx and cy) then
      cx,cy = self.centroid.x, self.centroid.y
    end
    for i,v in ipairs(self.vertices) do
      v.x,v.y = vector.add(cx,cy, vector.mul(s, v.x-cx, v.y-cy))
    end
    self._radius = self._radius * s
  end

  function Polygon:triangulate()
    if #self.vertices == 3 then return {self:clone()} end

    local vertices = self.vertices

    local next_idx, prev_idx = {}, {}
    for i = 1,#vertices do
      next_idx[i], prev_idx[i] = i+1,i-1
    end
    next_idx[#next_idx], prev_idx[1] = 1, #prev_idx

    local concave = {}
    for i, v in ipairs(vertices) do
      if not ccw(vertices[prev_idx[i]], v, vertices[next_idx[i]]) then
        concave[v] = true
      end
    end

    local triangles = {}
    local n_vert, current, skipped, next, prev = #vertices, 1, 0
    while n_vert > 3 do
      next, prev = next_idx[current], prev_idx[current]
      local p,q,r = vertices[prev], vertices[current], vertices[next]
      if isEar(p,q,r, concave) then
        if not areCollinear(p, q, r) then
          triangles[#triangles+1] = newPolygon(p.x,p.y, q.x,q.y, r.x,r.y)
          next_idx[prev], prev_idx[next] = next, prev
          concave[q] = nil
          n_vert, skipped = n_vert - 1, 0
        end
      else
        skipped = skipped + 1
        assert(skipped <= n_vert, "Cannot triangulate polygon")
      end
      current = next
    end

    next, prev = next_idx[current], prev_idx[current]
    local p,q,r = vertices[prev], vertices[current], vertices[next]
    triangles[#triangles+1] = newPolygon(p.x,p.y, q.x,q.y, r.x,r.y)
    return triangles
  end

  function Polygon:mergedWith(other)
    local p,q = getSharedEdge(self.vertices, other.vertices)
    assert(p and q, "Polygons do not share an edge")

    local ret = {}
    for i = 1,p-1 do
      ret[#ret+1] = self.vertices[i].x
      ret[#ret+1] = self.vertices[i].y
    end

    for i = 0,#other.vertices-2 do
      i = ((i-1 + q) % #other.vertices) + 1
      ret[#ret+1] = other.vertices[i].x
      ret[#ret+1] = other.vertices[i].y
    end

    for i = p+1,#self.vertices do
      ret[#ret+1] = self.vertices[i].x
      ret[#ret+1] = self.vertices[i].y
    end

    return newPolygon(unpack(ret))
  end

  function Polygon:splitConvex()
    if #self.vertices <= 3 or self:isConvex() then return {self:clone()} end

    local convex = self:triangulate()
    local i = 1
    repeat
      local p = convex[i]
      local k = i + 1
      while k <= #convex do
        local success, merged = pcall(function() return p:mergedWith(convex[k]) end)
        if success and merged:isConvex() then
          convex[i] = merged
          p = convex[i]
          table.remove(convex, k)
        else
          k = k + 1
        end
      end
      i = i + 1
    until i >= #convex

    return convex
  end

  function Polygon:contains(x,y)
    local function cut_ray(p,q)
      return ((p.y > y and q.y < y) or (p.y < y and q.y > y))
        and (x - p.x < (y - p.y) * (q.x - p.x) / (q.y - p.y))
    end

    local function cross_boundary(p,q)
      return (p.y == y and p.x > x and q.y < y)
        or (q.y == y and q.x > x and p.y < y)
    end

    local v = self.vertices
    local in_polygon = false
    local p,q = v[#v],v[#v]
    for i = 1, #v do
      p,q = q,v[i]
      if cut_ray(p,q) or cross_boundary(p,q) then
        in_polygon = not in_polygon
      end
    end
    return in_polygon
  end

  function Polygon:intersectionsWithRay(x,y, dx,dy)
    local nx,ny = vector.perpendicular(dx,dy)
    local wx,wy,det

    local ts = {}
    local q1,q2 = nil, self.vertices[#self.vertices]
    for i = 1, #self.vertices do
      q1,q2 = q2,self.vertices[i]
      wx,wy = q2.x - q1.x, q2.y - q1.y
      det = vector.det(dx,dy, wx,wy)

      if det ~= 0 then
        local rx,ry = q2.x - x, q2.y - y
        local l = vector.det(rx,ry, wx,wy) / det
        local m = vector.det(dx,dy, rx,ry) / det
        if m >= 0 and m <= 1 then
          ts[#ts+1] = l
        end
      else
        local dist = vector.dot(q1.x-x,q1.y-y, nx,ny)
        if dist == 0 then
          local l = vector.dot(dx,dy, q1.x-x,q1.y-y)
          local m = vector.dot(dx,dy, q2.x-x,q2.y-y)
          if l >= m then
            ts[#ts+1] = l
          else
            ts[#ts+1] = m
          end
        end
      end
    end

    return ts
  end

  function Polygon:intersectsRay(x,y, dx,dy)
    local tmin = math.huge
    for _, t in ipairs(self:intersectionsWithRay(x,y,dx,dy)) do
      tmin = math.min(tmin, t)
    end
    return tmin ~= math.huge, tmin
  end

  Polygon = common_local.class('Polygon', Polygon)
  newPolygon = function(...) return common_local.instance(Polygon, ...) end
  return Polygon
end

--------------------------------------------------------------------------------
-- HC.spatialhash: Spatial hashing for efficient collision detection
--------------------------------------------------------------------------------
package.preload['HC.spatialhash'] = function()
  local floor = math.floor
  local min, max = math.min, math.max

  local _PACKAGE = 'HC'
  local common_local = common
  if not (type(common) == 'table' and common.class and common.instance) then
    assert(common_class ~= false, 'No class commons specification available.')
    require(_PACKAGE .. '.class')
    common_local, common = common, common_local
  end
  local vector  = require(_PACKAGE .. '.vector-light')

  local Spatialhash = {}
  function Spatialhash:init(cell_size)
    self.cell_size = cell_size or 100
    self.cells = {}
  end

  function Spatialhash:cellCoords(x,y)
    return floor(x / self.cell_size), floor(y / self.cell_size)
  end

  function Spatialhash:cell(i,k)
    local row = rawget(self.cells, i)
    if not row then
      row = {}
      rawset(self.cells, i, row)
    end

    local cell = rawget(row, k)
    if not cell then
      cell = {}
      rawset(row, k, cell)
    end

    return cell
  end

  function Spatialhash:cellAt(x,y)
    return self:cell(self:cellCoords(x,y))
  end

  function Spatialhash:shapes()
    local set = {}
    for i,row in pairs(self.cells) do
      for k,cell in pairs(row) do
        for obj in pairs(cell) do
          rawset(set, obj, obj)
        end
      end
    end
    return set
  end

  function Spatialhash:inSameCells(x1,y1, x2,y2)
    local set = {}
    x1, y1 = self:cellCoords(x1, y1)
    x2, y2 = self:cellCoords(x2, y2)
    for i = x1,x2 do
      for k = y1,y2 do
        for obj in pairs(self:cell(i,k)) do
          rawset(set, obj, obj)
        end
      end
    end
    return set
  end

  function Spatialhash:register(obj, x1, y1, x2, y2)
    x1, y1 = self:cellCoords(x1, y1)
    x2, y2 = self:cellCoords(x2, y2)
    for i = x1,x2 do
      for k = y1,y2 do
        rawset(self:cell(i,k), obj, obj)
      end
    end
  end

  function Spatialhash:remove(obj, x1, y1, x2,y2)
    if not (x1 and y1 and x2 and y2) then
      for _,row in pairs(self.cells) do
        for _,cell in pairs(row) do
          rawset(cell, obj, nil)
        end
      end
      return
    end

    x1,y1 = self:cellCoords(x1,y1)
    x2,y2 = self:cellCoords(x2,y2)
    for i = x1,x2 do
      for k = y1,y2 do
        rawset(self:cell(i,k), obj, nil)
      end
    end
  end

  function Spatialhash:update(obj, old_x1,old_y1, old_x2,old_y2, new_x1,new_y1, new_x2,new_y2)
    old_x1, old_y1 = self:cellCoords(old_x1, old_y1)
    old_x2, old_y2 = self:cellCoords(old_x2, old_y2)

    new_x1, new_y1 = self:cellCoords(new_x1, new_y1)
    new_x2, new_y2 = self:cellCoords(new_x2, new_y2)

    if old_x1 == new_x1 and old_y1 == new_y1 and
       old_x2 == new_x2 and old_y2 == new_y2 then
      return
    end

    for i = old_x1,old_x2 do
      for k = old_y1,old_y2 do
        rawset(self:cell(i,k), obj, nil)
      end
    end
    for i = new_x1,new_x2 do
      for k = new_y1,new_y2 do
        rawset(self:cell(i,k), obj, obj)
      end
    end
  end

  function Spatialhash:intersectionsWithSegment(x1, y1, x2, y2)
    local odx, ody = x2 - x1, y2 - y1
    local len, cur = vector.len(odx, ody), 0
    local dx, dy = vector.normalize(odx, ody)
    local step = self.cell_size / 2
    local visited = {}
    local points = {}
    local mt = math.huge

    while (cur + step < len) do
      local cx, cy = x1 + dx * cur,  y1 + dy * cur
      local shapes = self:cellAt(cx, cy)
      cur = cur + step

      for _, shape in pairs(shapes) do
        if (not visited[shape]) then
          local ints = shape:intersectionsWithRay(x1, y1, dx, dy)

          for _, t in ipairs(ints) do
            if (t >= 0 and t <= len) then
              local px, py = vector.add(x1, y1, vector.mul(t, dx, dy))
              table.insert(points, {shape, t, px, py})
            end
          end

          visited[shape] = true
        end
      end
    end

    table.sort(points, function(a, b)
      return a[2] < b[2]
    end)

    return points
  end

  -- Note: draw() function removed as it depends on LOVE graphics

  return common_local.class('Spatialhash', Spatialhash)
end

--------------------------------------------------------------------------------
-- HC.shapes: Shape classes (circle, polygon, point)
--------------------------------------------------------------------------------
package.preload['HC.shapes'] = function()
  local math_min, math_sqrt, math_huge = math.min, math.sqrt, math.huge

  local _PACKAGE = 'HC'
  local common_local = common
  if not (type(common) == 'table' and common.class and common.instance) then
    assert(common_class ~= false, 'No class commons specification available.')
    require(_PACKAGE .. '.class')
  end
  local vector  = require(_PACKAGE .. '.vector-light')
  local Polygon = require(_PACKAGE .. '.polygon')
  local GJK     = require(_PACKAGE .. '.gjk')

  if common_local ~= common then
    common_local, common = common, common_local
  end

  local Shape = {}
  function Shape:init(t)
    self._type = t
    self._rotation = 0
  end

  function Shape:moveTo(x,y)
    local cx,cy = self:center()
    self:move(x - cx, y - cy)
  end

  function Shape:rotation()
    return self._rotation
  end

  function Shape:rotate(angle)
    self._rotation = self._rotation + angle
  end

  function Shape:setRotation(angle, x,y)
    return self:rotate(angle - self._rotation, x,y)
  end

  local ConvexPolygonShape = {}
  function ConvexPolygonShape:init(polygon)
    Shape.init(self, 'polygon')
    assert(polygon:isConvex(), "Polygon is not convex.")
    self._polygon = polygon
  end

  local ConcavePolygonShape = {}
  function ConcavePolygonShape:init(poly)
    Shape.init(self, 'compound')
    self._polygon = poly
    self._shapes = poly:splitConvex()
    for i,s in ipairs(self._shapes) do
      self._shapes[i] = common_local.instance(ConvexPolygonShape, s)
    end
  end

  local CircleShape = {}
  function CircleShape:init(cx,cy, radius)
    Shape.init(self, 'circle')
    self._center = {x = cx, y = cy}
    self._radius = radius
  end

  local PointShape = {}
  function PointShape:init(x,y)
    Shape.init(self, 'point')
    self._pos = {x = x, y = y}
  end

  function ConvexPolygonShape:support(dx,dy)
    local v = self._polygon.vertices
    local max, vmax = -math_huge
    for i = 1,#v do
      local d = vector.dot(v[i].x,v[i].y, dx,dy)
      if d > max then
        max, vmax = d, v[i]
      end
    end
    return vmax.x, vmax.y
  end

  function CircleShape:support(dx,dy)
    return vector.add(self._center.x, self._center.y,
      vector.mul(self._radius, vector.normalize(dx,dy)))
  end

  function ConvexPolygonShape:collidesWith(other)
    if self == other then return false end
    if other._type ~= 'polygon' then
      local collide, sx,sy = other:collidesWith(self)
      return collide, sx and -sx, sy and -sy
    end
    return GJK(self, other)
  end

  function ConcavePolygonShape:collidesWith(other)
    if self == other then return false end
    if other._type == 'point' then
      return other:collidesWith(self)
    end

    local collide,dx,dy = false,0,0
    for _,s in ipairs(self._shapes) do
      local status, sx,sy = s:collidesWith(other)
      collide = collide or status
      if status then
        if math.abs(dx) < math.abs(sx) then
          dx = sx
        end
        if math.abs(dy) < math.abs(sy) then
          dy = sy
        end
      end
    end
    return collide, dx, dy
  end

  function CircleShape:collidesWith(other)
    if self == other then return false end
    if other._type == 'circle' then
      local px,py = self._center.x-other._center.x, self._center.y-other._center.y
      local d = vector.len2(px,py)
      local radii = self._radius + other._radius
      if d < radii*radii then
        if d == 0 then return true, 0,radii end
        return true, vector.mul(radii - math_sqrt(d), vector.normalize(px,py))
      end
      return false
    elseif other._type == 'polygon' then
      return GJK(self, other)
    end

    local collide, sx,sy = other:collidesWith(self)
    return collide, sx and -sx, sy and -sy
  end

  function PointShape:collidesWith(other)
    if self == other then return false end
    if other._type == 'point' then
      return (self._pos == other._pos), 0,0
    end
    return other:contains(self._pos.x, self._pos.y), 0,0
  end

  function ConvexPolygonShape:contains(x,y)
    return self._polygon:contains(x,y)
  end

  function ConcavePolygonShape:contains(x,y)
    return self._polygon:contains(x,y)
  end

  function CircleShape:contains(x,y)
    return vector.len2(x-self._center.x, y-self._center.y) < self._radius * self._radius
  end

  function PointShape:contains(x,y)
    return x == self._pos.x and y == self._pos.y
  end

  function ConcavePolygonShape:intersectsRay(x,y, dx,dy)
    return self._polygon:intersectsRay(x,y, dx,dy)
  end

  function ConvexPolygonShape:intersectsRay(x,y, dx,dy)
    return self._polygon:intersectsRay(x,y, dx,dy)
  end

  function ConcavePolygonShape:intersectionsWithRay(x,y, dx,dy)
    return self._polygon:intersectionsWithRay(x,y, dx,dy)
  end

  function ConvexPolygonShape:intersectionsWithRay(x,y, dx,dy)
    return self._polygon:intersectionsWithRay(x,y, dx,dy)
  end

  function CircleShape:intersectionsWithRay(x,y, dx,dy)
    local pcx,pcy = x-self._center.x, y-self._center.y

    local a = vector.len2(dx,dy)
    local b = 2 * vector.dot(dx,dy, pcx,pcy)
    local c = vector.len2(pcx,pcy) - self._radius * self._radius
    local discr = b*b - 4*a*c

    if discr < 0 then return {} end

    discr = math_sqrt(discr)
    local ts, t1, t2 = {}, discr-b, -discr-b
    if t1 >= 0 then ts[#ts+1] = t1/(2*a) end
    if t2 >= 0 then ts[#ts+1] = t2/(2*a) end
    return ts
  end

  function CircleShape:intersectsRay(x,y, dx,dy)
    local tmin = math_huge
    for _, t in ipairs(self:intersectionsWithRay(x,y,dx,dy)) do
      tmin = math_min(t, tmin)
    end
    return tmin ~= math_huge, tmin
  end

  function PointShape:intersectsRay(x,y, dx,dy)
    local px,py = self._pos.x-x, self._pos.y-y
    local t = px/dx
    return (t == py/dy), t
  end

  function PointShape:intersectionsWithRay(x,y, dx,dy)
    local intersects, t = self:intersectsRay(x,y, dx,dy)
    return intersects and {t} or {}
  end

  function ConvexPolygonShape:center()
    return self._polygon.centroid.x, self._polygon.centroid.y
  end

  function ConcavePolygonShape:center()
    return self._polygon.centroid.x, self._polygon.centroid.y
  end

  function CircleShape:center()
    return self._center.x, self._center.y
  end

  function PointShape:center()
    return self._pos.x, self._pos.y
  end

  function ConvexPolygonShape:outcircle()
    local cx,cy = self:center()
    return cx,cy, self._polygon._radius
  end

  function ConcavePolygonShape:outcircle()
    local cx,cy = self:center()
    return cx,cy, self._polygon._radius
  end

  function CircleShape:outcircle()
    local cx,cy = self:center()
    return cx,cy, self._radius
  end

  function PointShape:outcircle()
    return self._pos.x, self._pos.y, 0
  end

  function ConvexPolygonShape:bbox()
    return self._polygon:bbox()
  end

  function ConcavePolygonShape:bbox()
    return self._polygon:bbox()
  end

  function CircleShape:bbox()
    local cx,cy = self:center()
    local r = self._radius
    return cx-r,cy-r, cx+r,cy+r
  end

  function PointShape:bbox()
    local x,y = self:center()
    return x,y,x,y
  end

  function ConvexPolygonShape:move(x,y)
    self._polygon:move(x,y)
  end

  function ConcavePolygonShape:move(x,y)
    self._polygon:move(x,y)
    for _,p in ipairs(self._shapes) do
      p:move(x,y)
    end
  end

  function CircleShape:move(x,y)
    self._center.x = self._center.x + x
    self._center.y = self._center.y + y
  end

  function PointShape:move(x,y)
    self._pos.x = self._pos.x + x
    self._pos.y = self._pos.y + y
  end

  function ConcavePolygonShape:rotate(angle,cx,cy)
    Shape.rotate(self, angle)
    if not (cx and cy) then
      cx,cy = self:center()
    end
    self._polygon:rotate(angle,cx,cy)
    for _,p in ipairs(self._shapes) do
      p:rotate(angle, cx,cy)
    end
  end

  function ConvexPolygonShape:rotate(angle, cx,cy)
    Shape.rotate(self, angle)
    self._polygon:rotate(angle, cx, cy)
  end

  function CircleShape:rotate(angle, cx,cy)
    Shape.rotate(self, angle)
    if not (cx and cy) then return end
    self._center.x,self._center.y = vector.add(cx,cy, vector.rotate(angle, self._center.x-cx, self._center.y-cy))
  end

  function PointShape:rotate(angle, cx,cy)
    Shape.rotate(self, angle)
    if not (cx and cy) then return end
    self._pos.x,self._pos.y = vector.add(cx,cy, vector.rotate(angle, self._pos.x-cx, self._pos.y-cy))
  end

  function ConcavePolygonShape:scale(s)
    assert(type(s) == "number" and s > 0, "Invalid argument. Scale must be greater than 0")
    local cx,cy = self:center()
    self._polygon:scale(s, cx,cy)
    for _, p in ipairs(self._shapes) do
      local dx,dy = vector.sub(cx,cy, p:center())
      p:scale(s)
      p:moveTo(cx-dx*s, cy-dy*s)
    end
  end

  function ConvexPolygonShape:scale(s)
    assert(type(s) == "number" and s > 0, "Invalid argument. Scale must be greater than 0")
    self._polygon:scale(s, self:center())
  end

  function CircleShape:scale(s)
    assert(type(s) == "number" and s > 0, "Invalid argument. Scale must be greater than 0")
    self._radius = self._radius * s
  end

  function PointShape:scale()
    -- nothing
  end

  -- Note: draw() functions removed as they depend on LOVE graphics

  Shape = common_local.class('Shape', Shape)
  ConvexPolygonShape  = common_local.class('ConvexPolygonShape',  ConvexPolygonShape,  Shape)
  ConcavePolygonShape = common_local.class('ConcavePolygonShape', ConcavePolygonShape, Shape)
  CircleShape         = common_local.class('CircleShape',         CircleShape,         Shape)
  PointShape          = common_local.class('PointShape',          PointShape,          Shape)

  local function newPolygonShape(polygon, ...)
    if type(polygon) == "number" then
      polygon = common_local.instance(Polygon, polygon, ...)
    else
      polygon = polygon:clone()
    end

    if polygon:isConvex() then
      return common_local.instance(ConvexPolygonShape, polygon)
    end

    return common_local.instance(ConcavePolygonShape, polygon)
  end

  local function newCircleShape(...)
    return common_local.instance(CircleShape, ...)
  end

  local function newPointShape(...)
    return common_local.instance(PointShape, ...)
  end

  return {
    ConcavePolygonShape = ConcavePolygonShape,
    ConvexPolygonShape  = ConvexPolygonShape,
    CircleShape         = CircleShape,
    PointShape          = PointShape,
    newPolygonShape     = newPolygonShape,
    newCircleShape      = newCircleShape,
    newPointShape       = newPointShape,
  }
end

--------------------------------------------------------------------------------
-- Main HC module
--------------------------------------------------------------------------------
local _NAME = 'HC'
local common_local = common
if not (type(common) == 'table' and common.class and common.instance) then
  assert(common_class ~= false, 'No class commons specification available.')
  require(_NAME .. '.class')
end
local Shapes      = require(_NAME .. '.shapes')
local Spatialhash = require(_NAME .. '.spatialhash')

if common_local ~= common then
  common_local, common = common, common_local
end

local newPolygonShape = Shapes.newPolygonShape
local newCircleShape  = Shapes.newCircleShape
local newPointShape   = Shapes.newPointShape

---@class HC
---@field new fun(cell_size?: number): HC Create a new HC instance with optional spatial hash cell size
---@field resetHash fun(cell_size?: number): HC Reset the spatial hash with optional new cell size
---@field register fun(shape: Shape): Shape Register a shape with the collision system
---@field remove fun(shape: Shape): HC Remove a shape from the collision system
---@field polygon fun(...): Shape Create and register a polygon shape from coordinates
---@field rectangle fun(x: number, y: number, w: number, h: number): Shape Create and register a rectangle shape
---@field circle fun(x: number, y: number, r: number): Shape Create and register a circle shape
---@field point fun(x: number, y: number): Shape Create and register a point shape
---@field neighbors fun(shape: Shape): table Get shapes that might collide with the given shape
---@field collisions fun(shape: Shape): table Get all shapes colliding with the given shape
---@field shapesAt fun(x: number, y: number): table Get all shapes containing the point
local HC = {}

--- Initialize the HC collision system
---@param cell_size? number Size of spatial hash cells (default: 100)
function HC:init(cell_size)
  self:resetHash(cell_size)
end

--- Get the spatial hash used by this instance
---@return table The spatial hash object
function HC:hash() return self._hash end

--- Reset the spatial hash, optionally with a new cell size
---@param cell_size? number Size of spatial hash cells (default: 100)
---@return HC self Returns self for chaining
function HC:resetHash(cell_size)
  self._hash = common_local.instance(Spatialhash, cell_size or 100)
  return self
end

--- Register a shape with the collision detection system
--- Automatically tracks shape movement, rotation, and scaling
---@param shape Shape The shape to register
---@return Shape shape Returns the registered shape
function HC:register(shape)
  self._hash:register(shape, shape:bbox())

  for _, f in ipairs({'move', 'rotate', 'scale'}) do
    local old_function = shape[f]
    shape[f] = function(this, ...)
      local x1,y1,x2,y2 = this:bbox()
      old_function(this, ...)
      self._hash:update(this, x1,y1,x2,y2, this:bbox())
      return this
    end
  end

  return shape
end

--- Remove a shape from the collision detection system
---@param shape Shape The shape to remove
---@return HC self Returns self for chaining
function HC:remove(shape)
  self._hash:remove(shape, shape:bbox())
  for _, f in ipairs({'move', 'rotate', 'scale'}) do
    shape[f] = function()
      error(f.."() called on a removed shape")
    end
  end
  return self
end

--- Create and register a polygon shape from vertex coordinates
---@param ... number Vertex coordinates as x1,y1, x2,y2, ...
---@return Shape shape The created polygon shape
function HC:polygon(...)
  return self:register(newPolygonShape(...))
end

--- Create and register a rectangle shape
---@param x number Left edge x coordinate
---@param y number Top edge y coordinate
---@param w number Width
---@param h number Height
---@return Shape shape The created rectangle shape
function HC:rectangle(x,y,w,h)
  return self:polygon(x,y, x+w,y, x+w,y+h, x,y+h)
end

--- Create and register a circle shape
---@param x number Center x coordinate
---@param y number Center y coordinate
---@param r number Radius
---@return Shape shape The created circle shape
function HC:circle(x,y,r)
  return self:register(newCircleShape(x,y,r))
end

--- Create and register a point shape
---@param x number X coordinate
---@param y number Y coordinate
---@return Shape shape The created point shape
function HC:point(x,y)
  return self:register(newPointShape(x,y))
end

--- Get all shapes that might collide with the given shape (broad phase)
--- Uses spatial hashing for efficient neighbor lookup
---@param shape Shape The shape to check
---@return table neighbors Table of potential collision candidates
function HC:neighbors(shape)
  local neighbors = self._hash:inSameCells(shape:bbox())
  rawset(neighbors, shape, nil)
  return neighbors
end

--- Get all shapes colliding with the given shape
--- Returns collision data including separation vectors
---@param shape Shape The shape to check collisions for
---@return table collisions Table mapping colliding shapes to {x=dx, y=dy} separation vectors
function HC:collisions(shape)
  local candidates = self:neighbors(shape)
  for other in pairs(candidates) do
    local collides, dx, dy = shape:collidesWith(other)
    if collides then
      rawset(candidates, other, {dx,dy, x=dx, y=dy})
    else
      rawset(candidates, other, nil)
    end
  end
  return candidates
end

--- Cast a ray and find all intersections with registered shapes
---@param x number Ray origin x coordinate
---@param y number Ray origin y coordinate
---@param dx number Ray direction x component
---@param dy number Ray direction y component
---@param range number Maximum ray distance
---@return table intersections Table of intersection data
function HC:raycast(x, y, dx, dy, range)
  local dxr, dyr = dx * range, dy * range
  local bbox = { x + dxr , y + dyr, x, y }
  local candidates = self._hash:inSameCells(unpack(bbox))

  for col in pairs(candidates) do
    local rparams = col:intersectionsWithRay(x, y, dx, dy)
    if #rparams > 0 then
      for i, rparam in pairs(rparams) do
        if rparam < 0 or rparam > range then
          rawset(rparams, i, nil)
        else
          local hitx, hity = x + (rparam * dx), y + (rparam * dy)
          rawset(rparams, i, { x = hitx, y = hity })
        end
      end
      rawset(candidates, col, rparams)
    else
      rawset(candidates, col, nil)
    end
  end
  return candidates
end

--- Get all shapes containing a specific point
---@param x number X coordinate
---@param y number Y coordinate
---@return table shapes Table of shapes containing the point
function HC:shapesAt(x, y)
  local candidates = {}
  for c in pairs(self._hash:cellAt(x, y)) do
    if c:contains(x, y) then
      rawset(candidates, c, c)
    end
  end
  return candidates
end

-- Create the class and default instance
HC = common_local.class('HC', HC)
local instance = common_local.instance(HC)

-- Return module with both class methods and instance methods
-- Note: wrapper functions accept (self, ...) to support colon syntax: HC:circle(x, y, r)
return setmetatable({
  --- Create a new HC collision detection instance
  ---@param cell_size? number Size of spatial hash cells (default: 100)
  ---@return HC A new HC instance
  new       = function(_, ...) return common_local.instance(HC, ...) end,

  --- Reset the default instance's spatial hash
  ---@param cell_size? number Size of spatial hash cells (default: 100)
  ---@return HC The default instance
  resetHash = function(_, ...) return instance:resetHash(...) end,

  --- Register a shape with the default instance
  ---@param shape Shape The shape to register
  ---@return Shape The registered shape
  register  = function(_, ...) return instance:register(...) end,

  --- Remove a shape from the default instance
  ---@param shape Shape The shape to remove
  ---@return HC The default instance
  remove    = function(_, ...) return instance:remove(...) end,

  --- Create and register a polygon with the default instance
  ---@param ... number Vertex coordinates as x1,y1, x2,y2, ...
  ---@return Shape The created polygon shape
  polygon   = function(_, ...) return instance:polygon(...) end,

  --- Create and register a rectangle with the default instance
  ---@param x number Left edge x coordinate
  ---@param y number Top edge y coordinate
  ---@param w number Width
  ---@param h number Height
  ---@return Shape The created rectangle shape
  rectangle = function(_, ...) return instance:rectangle(...) end,

  --- Create and register a circle with the default instance
  ---@param x number Center x coordinate
  ---@param y number Center y coordinate
  ---@param r number Radius
  ---@return Shape The created circle shape
  circle    = function(_, ...) return instance:circle(...) end,

  --- Create and register a point with the default instance
  ---@param x number X coordinate
  ---@param y number Y coordinate
  ---@return Shape The created point shape
  point     = function(_, ...) return instance:point(...) end,

  --- Get neighbors of a shape using the default instance
  ---@param shape Shape The shape to check
  ---@return table Potential collision candidates
  neighbors  = function(_, ...) return instance:neighbors(...) end,

  --- Get collisions for a shape using the default instance
  ---@param shape Shape The shape to check
  ---@return table Colliding shapes with separation vectors
  collisions = function(_, ...) return instance:collisions(...) end,

  --- Get shapes at a point using the default instance
  ---@param x number X coordinate
  ---@param y number Y coordinate
  ---@return table Shapes containing the point
  shapesAt   = function(_, ...) return instance:shapesAt(...) end,

  --- Get the spatial hash of the default instance
  ---@return table The spatial hash
  hash       = function() return instance:hash() end,
}, {__call = function(_, ...) return common_local.instance(HC, ...) end})
\`;

  // src/runtime/canvas-standalone.ts
  var canvasLuaCode = canvasLuaCoreCode + canvasLuaPathCode + canvasLuaStylingCode + canvasLuaTextCode + canvasLuaInputCode + canvasLuaAudioCode;
  var hcLuaCode = LUA_HC_CODE;
  function createCanvasRuntimeState(canvas) {
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) {
      throw new Error("Could not get 2D rendering context");
    }
    return {
      canvas,
      ctx,
      isRunning: false,
      tickCallback: null,
      lastFrameTime: 0,
      deltaTime: 0,
      totalTime: 0,
      keysDown: /* @__PURE__ */ new Set(),
      keysPressed: /* @__PURE__ */ new Set(),
      mouseX: 0,
      mouseY: 0,
      mouseButtonsDown: /* @__PURE__ */ new Set(),
      mouseButtonsPressed: /* @__PURE__ */ new Set(),
      currentFontSize: 16,
      currentFontFamily: "monospace",
      stopResolve: null,
      // audioEngine is set by AUDIO_INLINE_JS's setupAudioBridge
      audioAssets: /* @__PURE__ */ new Map(),
      // Gamepad state for "just pressed" detection
      previousGamepadButtons: [[], [], [], []]
    };
  }
  function setupInputListeners(state) {
    const handleKeyDown = (e) => {
      if (!state.keysDown.has(e.code)) {
        state.keysPressed.add(e.code);
      }
      state.keysDown.add(e.code);
    };
    const handleKeyUp = (e) => {
      state.keysDown.delete(e.code);
    };
    const handleMouseMove = (e) => {
      const rect = state.canvas.getBoundingClientRect();
      const displayX = e.clientX - rect.left;
      const displayY = e.clientY - rect.top;
      state.mouseX = displayX * (state.canvas.width / rect.width);
      state.mouseY = displayY * (state.canvas.height / rect.height);
    };
    const handleMouseDown = (e) => {
      if (!state.mouseButtonsDown.has(e.button)) {
        state.mouseButtonsPressed.add(e.button);
      }
      state.mouseButtonsDown.add(e.button);
    };
    const handleMouseUp = (e) => {
      state.mouseButtonsDown.delete(e.button);
    };
    const handleContextMenu = (e) => {
      e.preventDefault();
    };
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
    state.canvas.addEventListener("mousemove", handleMouseMove);
    state.canvas.addEventListener("mousedown", handleMouseDown);
    state.canvas.addEventListener("mouseup", handleMouseUp);
    state.canvas.addEventListener("contextmenu", handleContextMenu);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
      state.canvas.removeEventListener("mousemove", handleMouseMove);
      state.canvas.removeEventListener("mousedown", handleMouseDown);
      state.canvas.removeEventListener("mouseup", handleMouseUp);
      state.canvas.removeEventListener("contextmenu", handleContextMenu);
    };
  }
  function startGameLoop(state) {
    state.lastFrameTime = performance.now();
    function gameLoop(timestamp) {
      if (!state.isRunning) return;
      state.deltaTime = (timestamp - state.lastFrameTime) / 1e3;
      state.lastFrameTime = timestamp;
      state.totalTime += state.deltaTime;
      if (state.tickCallback) {
        try {
          state.tickCallback();
        } catch (err) {
          console.error("Lua error in tick callback:", err);
          state.isRunning = false;
          if (state.stopResolve) {
            state.stopResolve();
            state.stopResolve = null;
          }
          return;
        }
      }
      state.keysPressed.clear();
      state.mouseButtonsPressed.clear();
      const gamepads = navigator.getGamepads?.() ?? [];
      for (let i = 0; i < 4; i++) {
        const gamepad = gamepads[i];
        if (gamepad?.connected) {
          state.previousGamepadButtons[i] = gamepad.buttons.map((b) => b.value);
        } else {
          state.previousGamepadButtons[i] = [];
        }
      }
      if (state.isRunning) {
        requestAnimationFrame(gameLoop);
      }
    }
    requestAnimationFrame(gameLoop);
  }
  function toHex(value) {
    const hex = Math.max(0, Math.min(255, Math.round(value))).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }
  function colorToCss(r, g, b, a) {
    if (a !== void 0 && a !== null && a !== 255) {
      return \`rgba(\${r}, \${g}, \${b}, \${a / 255})\`;
    }
    return \`#\${toHex(r)}\${toHex(g)}\${toHex(b)}\`;
  }
  function setupCanvasBridge(engine, state) {
    const { ctx, canvas } = state;
    ctx.font = \`\${state.currentFontSize}px \${state.currentFontFamily}\`;
    ctx.textBaseline = "top";
    engine.global.set("__canvas_is_active", () => state.isRunning);
    engine.global.set("__canvas_start", async () => {
      return new Promise((resolve) => {
        state.isRunning = true;
        state.stopResolve = resolve;
        startGameLoop(state);
      });
    });
    engine.global.set("__canvas_stop", () => {
      state.isRunning = false;
      if (state.stopResolve) {
        state.stopResolve();
        state.stopResolve = null;
      }
    });
    engine.global.set(
      "__canvas_setOnDrawCallback",
      (callback) => {
        state.tickCallback = callback;
      }
    );
    engine.global.set("__canvas_setSize", (width, height) => {
      canvas.width = width;
      canvas.height = height;
    });
    engine.global.set("__canvas_getWidth", () => canvas.width);
    engine.global.set("__canvas_getHeight", () => canvas.height);
    engine.global.set("__canvas_clear", () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
    engine.global.set(
      "__canvas_clearRect",
      (x, y, width, height) => {
        ctx.clearRect(x, y, width, height);
      }
    );
    engine.global.set(
      "__canvas_setColor",
      (r, g, b, a) => {
        const color = colorToCss(r, g, b, a);
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
      }
    );
    engine.global.set("__canvas_setLineWidth", (width) => {
      ctx.lineWidth = width;
    });
    engine.global.set("__canvas_setFontSize", (size) => {
      state.currentFontSize = size;
      ctx.font = \`\${state.currentFontSize}px \${state.currentFontFamily}\`;
    });
    engine.global.set("__canvas_setFontFamily", (family) => {
      state.currentFontFamily = family;
      ctx.font = \`\${state.currentFontSize}px \${state.currentFontFamily}\`;
    });
    engine.global.set("__canvas_getTextWidth", (text) => {
      return ctx.measureText(text).width;
    });
    engine.global.set(
      "__canvas_rect",
      (x, y, width, height) => {
        ctx.strokeRect(x, y, width, height);
      }
    );
    engine.global.set(
      "__canvas_fillRect",
      (x, y, width, height) => {
        ctx.fillRect(x, y, width, height);
      }
    );
    engine.global.set(
      "__canvas_circle",
      (x, y, radius) => {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    );
    engine.global.set(
      "__canvas_fillCircle",
      (x, y, radius) => {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
    );
    engine.global.set(
      "__canvas_line",
      (x1, y1, x2, y2) => {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    );
    engine.global.set(
      "__canvas_text",
      (x, y, text, fontSize, fontFamily, maxWidth) => {
        const savedFont = ctx.font;
        if (fontSize || fontFamily) {
          const size = fontSize ?? state.currentFontSize;
          const family = fontFamily ?? state.currentFontFamily;
          ctx.font = \`\${size}px \${family}\`;
        }
        if (maxWidth) {
          ctx.fillText(text, x, y, maxWidth);
        } else {
          ctx.fillText(text, x, y);
        }
        ctx.font = savedFont;
      }
    );
    engine.global.set(
      "__canvas_strokeText",
      (x, y, text, fontSize, fontFamily, maxWidth) => {
        const savedFont = ctx.font;
        if (fontSize || fontFamily) {
          const size = fontSize ?? state.currentFontSize;
          const family = fontFamily ?? state.currentFontFamily;
          ctx.font = \`\${size}px \${family}\`;
        }
        if (maxWidth) {
          ctx.strokeText(text, x, y, maxWidth);
        } else {
          ctx.strokeText(text, x, y);
        }
        ctx.font = savedFont;
      }
    );
    engine.global.set("__canvas_getDelta", () => state.deltaTime);
    engine.global.set("__canvas_getTime", () => state.totalTime);
    engine.global.set(
      "__canvas_isKeyDown",
      (key) => state.keysDown.has(key)
    );
    engine.global.set(
      "__canvas_isKeyPressed",
      (key) => state.keysPressed.has(key)
    );
    engine.global.set("__canvas_getKeysDown", () => Array.from(state.keysDown));
    engine.global.set(
      "__canvas_getKeysPressed",
      () => Array.from(state.keysPressed)
    );
    engine.global.set("__canvas_getMouseX", () => state.mouseX);
    engine.global.set("__canvas_getMouseY", () => state.mouseY);
    engine.global.set(
      "__canvas_isMouseDown",
      (button) => state.mouseButtonsDown.has(button)
    );
    engine.global.set(
      "__canvas_isMousePressed",
      (button) => state.mouseButtonsPressed.has(button)
    );
    engine.global.set("__canvas_getGamepadCount", () => {
      const gamepads = navigator.getGamepads?.() ?? [];
      return Array.from(gamepads).filter((g) => g?.connected).length;
    });
    engine.global.set("__canvas_isGamepadConnected", (index) => {
      const gamepads = navigator.getGamepads?.() ?? [];
      return gamepads[index]?.connected ?? false;
    });
    engine.global.set(
      "__canvas_getGamepadButton",
      (gamepadIndex, buttonIndex) => {
        const gamepads = navigator.getGamepads?.() ?? [];
        const gamepad = gamepads[gamepadIndex];
        if (!gamepad?.connected) return 0;
        return gamepad.buttons[buttonIndex]?.value ?? 0;
      }
    );
    engine.global.set(
      "__canvas_isGamepadButtonPressed",
      (gamepadIndex, buttonIndex) => {
        const gamepads = navigator.getGamepads?.() ?? [];
        const gamepad = gamepads[gamepadIndex];
        if (!gamepad?.connected) return false;
        const currentValue = gamepad.buttons[buttonIndex]?.value ?? 0;
        const prevValue = state.previousGamepadButtons[gamepadIndex]?.[buttonIndex] ?? 0;
        return currentValue > 0 && prevValue === 0;
      }
    );
    engine.global.set(
      "__canvas_getGamepadAxis",
      (gamepadIndex, axisIndex) => {
        const gamepads = navigator.getGamepads?.() ?? [];
        const gamepad = gamepads[gamepadIndex];
        if (!gamepad?.connected) return 0;
        return gamepad.axes[axisIndex] ?? 0;
      }
    );
    engine.global.set("__canvas_translate", (dx, dy) => {
      ctx.translate(dx, dy);
    });
    engine.global.set("__canvas_rotate", (angle) => {
      ctx.rotate(angle);
    });
    engine.global.set("__canvas_scale", (sx, sy) => {
      ctx.scale(sx, sy);
    });
    engine.global.set("__canvas_save", () => {
      ctx.save();
    });
    engine.global.set("__canvas_restore", () => {
      ctx.restore();
    });
    engine.global.set(
      "__canvas_transform",
      (a, b, c, d, e, f) => {
        ctx.transform(a, b, c, d, e, f);
      }
    );
    engine.global.set(
      "__canvas_setTransform",
      (a, b, c, d, e, f) => {
        ctx.setTransform(a, b, c, d, e, f);
      }
    );
    engine.global.set("__canvas_resetTransform", () => {
      ctx.resetTransform();
    });
    engine.global.set("__canvas_beginPath", () => {
      ctx.beginPath();
    });
    engine.global.set("__canvas_closePath", () => {
      ctx.closePath();
    });
    engine.global.set("__canvas_moveTo", (x, y) => {
      ctx.moveTo(x, y);
    });
    engine.global.set("__canvas_lineTo", (x, y) => {
      ctx.lineTo(x, y);
    });
    engine.global.set("__canvas_fill", () => {
      ctx.fill();
    });
    engine.global.set("__canvas_stroke", () => {
      ctx.stroke();
    });
    engine.global.set(
      "__canvas_arc",
      (x, y, radius, startAngle, endAngle, counterclockwise) => {
        ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise);
      }
    );
    engine.global.set(
      "__canvas_arcTo",
      (x1, y1, x2, y2, radius) => {
        ctx.arcTo(x1, y1, x2, y2, radius);
      }
    );
    engine.global.set(
      "__canvas_quadraticCurveTo",
      (cpx, cpy, x, y) => {
        ctx.quadraticCurveTo(cpx, cpy, x, y);
      }
    );
    engine.global.set(
      "__canvas_bezierCurveTo",
      (cp1x, cp1y, cp2x, cp2y, x, y) => {
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      }
    );
    engine.global.set(
      "__canvas_ellipse",
      (x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) => {
        ctx.ellipse(
          x,
          y,
          radiusX,
          radiusY,
          rotation,
          startAngle,
          endAngle,
          counterclockwise
        );
      }
    );
    engine.global.set(
      "__canvas_roundRect",
      (x, y, width, height, radii) => {
        ctx.roundRect(x, y, width, height, radii);
      }
    );
    engine.global.set(
      "__canvas_rectPath",
      (x, y, width, height) => {
        ctx.rect(x, y, width, height);
      }
    );
    engine.global.set("__canvas_clip", (fillRule) => {
      if (fillRule) {
        ctx.clip(fillRule);
      } else {
        ctx.clip();
      }
    });
    engine.global.set(
      "__canvas_isPointInPath",
      (x, y, fillRule) => {
        return ctx.isPointInPath(x, y, fillRule);
      }
    );
    engine.global.set(
      "__canvas_isPointInStroke",
      (x, y) => {
        return ctx.isPointInStroke(x, y);
      }
    );
    engine.global.set("__canvas_setLineCap", (cap) => {
      ctx.lineCap = cap;
    });
    engine.global.set("__canvas_setLineJoin", (join) => {
      ctx.lineJoin = join;
    });
    engine.global.set("__canvas_setMiterLimit", (limit) => {
      ctx.miterLimit = limit;
    });
    engine.global.set("__canvas_setLineDash", (segments) => {
      ctx.setLineDash(segments);
    });
    engine.global.set("__canvas_getLineDash", () => {
      return ctx.getLineDash();
    });
    engine.global.set("__canvas_setLineDashOffset", (offset) => {
      ctx.lineDashOffset = offset;
    });
    engine.global.set("__canvas_setShadowColor", (color) => {
      ctx.shadowColor = color;
    });
    engine.global.set("__canvas_setShadowBlur", (blur) => {
      ctx.shadowBlur = blur;
    });
    engine.global.set("__canvas_setShadowOffsetX", (offset) => {
      ctx.shadowOffsetX = offset;
    });
    engine.global.set("__canvas_setShadowOffsetY", (offset) => {
      ctx.shadowOffsetY = offset;
    });
    engine.global.set(
      "__canvas_setShadow",
      (color, blur, offsetX, offsetY) => {
        ctx.shadowColor = color;
        ctx.shadowBlur = blur;
        ctx.shadowOffsetX = offsetX;
        ctx.shadowOffsetY = offsetY;
      }
    );
    engine.global.set("__canvas_clearShadow", () => {
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    });
    engine.global.set("__canvas_setGlobalAlpha", (alpha) => {
      ctx.globalAlpha = alpha;
    });
    engine.global.set(
      "__canvas_setCompositeOperation",
      (operation) => {
        ctx.globalCompositeOperation = operation;
      }
    );
    engine.global.set("__canvas_setImageSmoothing", (enabled) => {
      ctx.imageSmoothingEnabled = enabled;
    });
    engine.global.set("__canvas_setFilter", (filter) => {
      ctx.filter = filter;
    });
    engine.global.set("__canvas_setTextAlign", (align) => {
      ctx.textAlign = align;
    });
    engine.global.set(
      "__canvas_setTextBaseline",
      (baseline) => {
        ctx.textBaseline = baseline;
      }
    );
    engine.global.set(
      "__canvas_setDirection",
      (direction) => {
        ctx.direction = direction;
      }
    );
    engine.global.set("__canvas_getTextMetrics", (text) => {
      const metrics = ctx.measureText(text);
      return {
        width: metrics.width,
        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,
        actualBoundingBoxRight: metrics.actualBoundingBoxRight,
        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
        fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
        fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
      };
    });
    engine.global.set(
      "__canvas_capture",
      (format, quality) => {
        if (format && quality !== void 0 && quality !== null) {
          return canvas.toDataURL(format, quality);
        } else if (format) {
          return canvas.toDataURL(format);
        }
        return canvas.toDataURL();
      }
    );
    engine.global.set(
      "__canvas_setFillStyle",
      (style) => {
        if (typeof style === "string") {
          ctx.fillStyle = style;
        } else if (style.type === "linear") {
          const gradient = ctx.createLinearGradient(
            style.x0,
            style.y0,
            style.x1,
            style.y1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
        } else if (style.type === "radial") {
          const gradient = ctx.createRadialGradient(
            style.x0,
            style.y0,
            style.r0,
            style.x1,
            style.y1,
            style.r1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
        } else if (style.type === "conic") {
          const gradient = ctx.createConicGradient(
            style.startAngle,
            style.x,
            style.y
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.fillStyle = gradient;
        }
      }
    );
    engine.global.set(
      "__canvas_setStrokeStyle",
      (style) => {
        if (typeof style === "string") {
          ctx.strokeStyle = style;
        } else if (style.type === "linear") {
          const gradient = ctx.createLinearGradient(
            style.x0,
            style.y0,
            style.x1,
            style.y1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.strokeStyle = gradient;
        } else if (style.type === "radial") {
          const gradient = ctx.createRadialGradient(
            style.x0,
            style.y0,
            style.r0,
            style.x1,
            style.y1,
            style.r1
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.strokeStyle = gradient;
        } else if (style.type === "conic") {
          const gradient = ctx.createConicGradient(
            style.startAngle,
            style.x,
            style.y
          );
          const stops = style.stops;
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          ctx.strokeStyle = gradient;
        }
      }
    );
    engine.global.set("__canvas_assets_addPath", () => {
    });
    engine.global.set(
      "__canvas_assets_loadImage",
      (name, filename) => {
        return { _type: "image", _name: name, _file: filename };
      }
    );
    engine.global.set(
      "__canvas_assets_loadFont",
      (name, filename) => {
        return { _type: "font", _name: name, _file: filename };
      }
    );
    engine.global.set("__canvas_assets_getWidth", () => 0);
    engine.global.set("__canvas_assets_getHeight", () => 0);
    engine.global.set(
      "__canvas_drawImage",
      () => {
        console.warn("draw_image not fully supported in standalone export");
      }
    );
    engine.global.set(
      "__canvas_createImageData",
      (width, height) => {
        return { id: -1, width, height };
      }
    );
    engine.global.set(
      "__canvas_getImageData",
      (x, y, width, height) => {
        const imageData = ctx.getImageData(x, y, width, height);
        return { id: -1, width, height, data: Array.from(imageData.data) };
      }
    );
    engine.global.set(
      "__canvas_imageDataGetPixel",
      (_id, x, y, data, width) => {
        if (!data || !width) return [0, 0, 0, 0];
        const i = (y * width + x) * 4;
        return [data[i], data[i + 1], data[i + 2], data[i + 3]];
      }
    );
    engine.global.set("__canvas_imageDataSetPixel", () => {
    });
    engine.global.set("__canvas_putImageData", () => {
    });
    engine.global.set("__canvas_cloneImageData", () => null);
    engine.global.set("__canvas_createPath", () => ({ id: -1 }));
    engine.global.set("__canvas_clonePath", () => ({ id: -1 }));
    engine.global.set("__canvas_disposePath", () => {
    });
    engine.global.set("__canvas_pathMoveTo", () => {
    });
    engine.global.set("__canvas_pathLineTo", () => {
    });
    engine.global.set("__canvas_pathClosePath", () => {
    });
    engine.global.set("__canvas_pathRect", () => {
    });
    engine.global.set("__canvas_pathRoundRect", () => {
    });
    engine.global.set("__canvas_pathArc", () => {
    });
    engine.global.set("__canvas_pathArcTo", () => {
    });
    engine.global.set("__canvas_pathEllipse", () => {
    });
    engine.global.set("__canvas_pathQuadraticCurveTo", () => {
    });
    engine.global.set("__canvas_pathBezierCurveTo", () => {
    });
    engine.global.set("__canvas_pathAddPath", () => {
    });
    engine.global.set("__canvas_fillPath", () => {
    });
    engine.global.set("__canvas_strokePath", () => {
    });
    engine.global.set("__canvas_clipPath", () => {
    });
    engine.global.set("__canvas_isPointInStoredPath", () => false);
    engine.global.set("__canvas_isPointInStoredStroke", () => false);
    engine.global.set(
      "__canvas_assets_loadSound",
      (name, filename) => {
        state.audioAssets.set(name, { name, filename, type: "sound" });
        return { _type: "sound", _name: name, _file: filename };
      }
    );
    engine.global.set(
      "__canvas_assets_loadMusic",
      (name, filename) => {
        state.audioAssets.set(name, { name, filename, type: "music" });
        return { _type: "music", _name: name, _file: filename };
      }
    );
  }

  // src/runtime/canvas-inline-entry.ts
  globalThis.CanvasStandalone = {
    setupCanvasBridge,
    createCanvasRuntimeState,
    setupInputListeners,
    canvasLuaCode,
    hcLuaCode
  };
  globalThis.setupCanvasBridge = setupCanvasBridge;
  globalThis.createCanvasRuntimeState = createCanvasRuntimeState;
  globalThis.setupInputListeners = setupInputListeners;
  globalThis.canvasLuaCode = canvasLuaCode;
  globalThis.hcLuaCode = hcLuaCode;
})();
`
